/* eslint-disable */
<<<<<<< Updated upstream
// sequence-api v0.4.0 d7026da603b2c29baf21c6aceeebc86eada372d8
// --
// Code generated by Webrpc-gen@v0.31.0 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=typescript -client -out=./clients/api.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = 'd7026da603b2c29baf21c6aceeebc86eada372d8'

//
// Client interface
//

export interface APIClient {
  /**
   *
   * Runtime
   *
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>

  version(headers?: object, signal?: AbortSignal): Promise<VersionResponse>

  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse>

  clock(headers?: object, signal?: AbortSignal): Promise<ClockResponse>

  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextResponse>

  /**
   *
   * Auth
   *
   * TODO: rename 'ewtString' arg to 'ethauthProof'
   */
  getAuthToken(req: GetAuthTokenRequest, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenResponse>

  getAuthToken2(req: GetAuthToken2Request, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Response>

  sendPasswordlessLink(
    req: SendPasswordlessLinkRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SendPasswordlessLinkResponse>

  registerPublicKey(
    req: RegisterPublicKeyRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RegisterPublicKeyResponse>

  getPublicKey(req: GetPublicKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyResponse>

  /**
   *
   * Contacts / Friends
   *
   */
  friendList(req: FriendListRequest, headers?: object, signal?: AbortSignal): Promise<FriendListResponse>

  getFriendByAddress(
    req: GetFriendByAddressRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetFriendByAddressResponse>

  searchFriends(req: SearchFriendsRequest, headers?: object, signal?: AbortSignal): Promise<SearchFriendsResponse>

  addFriend(req: AddFriendRequest, headers?: object, signal?: AbortSignal): Promise<AddFriendResponse>

  updateFriendNickname(
    req: UpdateFriendNicknameRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateFriendNicknameResponse>

  removeFriend(req: RemoveFriendRequest, headers?: object, signal?: AbortSignal): Promise<RemoveFriendResponse>

  /**
   *
   * Chain-Utils
   *
   */
  contractCall(req: ContractCallRequest, headers?: object, signal?: AbortSignal): Promise<ContractCallResponse>

  decodeContractCall(
    req: DecodeContractCallRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DecodeContractCallResponse>

  lookupContractCallSelectors(
    req: LookupContractCallSelectorsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<LookupContractCallSelectorsResponse>

  /**
   *
   * User Storage
   *
   */
  userStorageFetch(
    req: UserStorageFetchRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchResponse>

  userStorageSave(req: UserStorageSaveRequest, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveResponse>

  userStorageDelete(
    req: UserStorageDeleteRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageDeleteResponse>

  userStorageFetchAll(
    req: UserStorageFetchAllRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchAllResponse>

  /**
   *
   * Wallet utils
   *
   */
  getMoonpayLink(req: GetMoonpayLinkRequest, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkResponse>

  /**
   * - IsUsingGoogleMail(domain: string) => (yes: bool)
   */
  resolveENSAddress(
    req: ResolveENSAddressRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ResolveENSAddressResponse>

  /**
   * TODO: we can add walletContext optional in the future when we need it
   * NOTE: chainId can be either a number or canonical name
   */
  isValidSignature(
    req: IsValidSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidSignatureResponse>

  isValidMessageSignature(
    req: IsValidMessageSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidMessageSignatureResponse>

  isValidTypedDataSignature(
    req: IsValidTypedDataSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidTypedDataSignatureResponse>

  isValidETHAuthProof(
    req: IsValidETHAuthProofRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidETHAuthProofResponse>

  getOnRampURL(req: GetOnRampURLRequest, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLResponse>

  transakGetCountries(headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesResponse>

  transakGetCryptoCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetCryptoCurrenciesResponse>

  transakGetFiatCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesResponse>

  transakGetPrice(req: TransakGetPriceRequest, headers?: object, signal?: AbortSignal): Promise<TransakGetPriceResponse>

  transakGetSupportedNFTCheckoutChains(
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetSupportedNFTCheckoutChainsResponse>

  transakGetWidgetURL(
    req: TransakGetWidgetURLRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetWidgetURLResponse>

  /**
   *
   * Price Feed
   *
   */
  getCoinPrices(req: GetCoinPricesRequest, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesResponse>

  getCollectiblePrices(
    req: GetCollectiblePricesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCollectiblePricesResponse>

  /**
   *
   * Price Feed utils
   *
   */
  getExchangeRate(req: GetExchangeRateRequest, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateResponse>

  /**
   *
   * Util / misc
   *
   */
  memoryStore(req: MemoryStoreRequest, headers?: object, signal?: AbortSignal): Promise<MemoryStoreResponse>

  memoryLoad(req: MemoryLoadRequest, headers?: object, signal?: AbortSignal): Promise<MemoryLoadResponse>

  /**
   *
   * Legacy
   *
   */
  getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoResponse>

  /**
   * NOTE: we're still using this from SW-API to Sequence-API to claim invite code
   */
  isValidAccessCode(
    req: IsValidAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidAccessCodeResponse>

  internalClaimAccessCode(
    req: InternalClaimAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<InternalClaimAccessCodeResponse>

  /**
   * Utils
   */
  blockNumberAtTime(
    req: BlockNumberAtTimeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<BlockNumberAtTimeResponse>

  /**
   *
   * Paper
   * TODO: deprecate in the future
   *
   */
  paperSessionSecret(
    req: PaperSessionSecretRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecretResponse>

  paperSessionSecret2(
    req: PaperSessionSecret2Request,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecret2Response>

  /**
   *
   * Linked wallets (v0 -- simple support)
   *
   */
  linkWallet(req: LinkWalletRequest, headers?: object, signal?: AbortSignal): Promise<LinkWalletResponse>

  getLinkedWallets(
    req: GetLinkedWalletsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLinkedWalletsResponse>

  removeLinkedWallet(
    req: RemoveLinkedWalletRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveLinkedWalletResponse>

  /**
   * NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
   * to be clear, they are not necessary for our linked wallets.
   */
  generateWaaSVerificationURL(
    req: GenerateWaaSVerificationURLRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GenerateWaaSVerificationURLResponse>

  validateWaaSVerificationNonce(
    req: ValidateWaaSVerificationNonceRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ValidateWaaSVerificationNonceResponse>

  /**
   *
   *
   * WaaS child wallet adoption
   *
   */
  listAdoptedWallets(
    req: ListAdoptedWalletsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListAdoptedWalletsResponse>

  getLifiChains(headers?: object, signal?: AbortSignal): Promise<GetLifiChainsResponse>

  getLifiTokens(req: GetLifiTokensRequest, headers?: object, signal?: AbortSignal): Promise<GetLifiTokensResponse>

  /**
   * All parameters except `params` are deprecated.
   * Use only the `params` object to pass values.
   */
  getLifiSwapRoutes(
    req: GetLifiSwapRoutesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapRoutesResponse>

  getLifiSwapQuote(
    req: GetLifiSwapQuoteRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapQuoteResponse>

  /**
   *
   * Chain abstraction
   *
   */
  getIntentCallsPayloads(
    req: GetIntentCallsPayloadsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentCallsPayloadsResponse>

  commitIntentConfig(
    req: CommitIntentConfigRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CommitIntentConfigResponse>

  getIntentConfig(req: GetIntentConfigRequest, headers?: object, signal?: AbortSignal): Promise<GetIntentConfigResponse>

  /**
   *
   * Inventory, payments and management
   *
   */
  listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsResponse>

  addOffchainInventory(
    req: AddOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddOffchainInventoryResponse>

  getOffchainInventory(
    req: GetOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetOffchainInventoryResponse>

  listOffchainInventories(
    req: ListOffchainInventoriesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainInventoriesResponse>

  updateOffchainInventory(
    req: UpdateOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateOffchainInventoryResponse>

  deleteOffchainInventory(
    req: DeleteOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteOffchainInventoryResponse>

  requestOffchainPayment(
    req: RequestOffchainPaymentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RequestOffchainPaymentResponse>

  listOffchainPayments(
    req: ListOffchainPaymentsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainPaymentsResponse>

  /**
   *
   * Packs
   *
   */
  savePack(req: SavePackRequest, headers?: object, signal?: AbortSignal): Promise<SavePackResponse>

  getPack(req: GetPackRequest, headers?: object, signal?: AbortSignal): Promise<GetPackResponse>

  getPackIds(req: GetPackIdsRequest, headers?: object, signal?: AbortSignal): Promise<GetPackIdsResponse>

  deletePack(req: DeletePackRequest, headers?: object, signal?: AbortSignal): Promise<DeletePackResponse>

  updatePackContent(
    req: UpdatePackContentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdatePackContentResponse>

  getRevealTxData(req: GetRevealTxDataRequest, headers?: object, signal?: AbortSignal): Promise<GetRevealTxDataResponse>

  checkoutOptionsPrimary(
    req: CheckoutOptionsPrimaryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsPrimaryResponse>

  checkoutOptionsSecondary(
    req: CheckoutOptionsSecondaryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsSecondaryResponse>

  checkoutOptionsGetTransakContractID(
    req: CheckoutOptionsGetTransakContractIDRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsGetTransakContractIDResponse>

  fortePayCreateIntent(
    req: FortePayCreateIntentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayCreateIntentResponse>

  fortePayGetPaymentStatuses(
    req: FortePayGetPaymentStatusesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayGetPaymentStatusesResponse>

  /**
   *
   * CCTP
   *
   */
  getCCTPTransfer(req: GetCCTPTransferRequest, headers?: object, signal?: AbortSignal): Promise<GetCCTPTransferResponse>

  queueCCTPTransfer(
    req: QueueCCTPTransferRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueCCTPTransferResponse>

  /**
   *
   * Intent Machine Worker
   *
   */
  queueIntentConfigExecution(
    req: QueueIntentConfigExecutionRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueIntentConfigExecutionResponse>

  getIntentConfigExecutionStatus(
    req: GetIntentConfigExecutionStatusRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigExecutionStatusResponse>

  listIntentConfigs(
    req: ListIntentConfigsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListIntentConfigsResponse>

  queueMetaTxnReceipt(
    req: QueueMetaTxnReceiptRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueMetaTxnReceiptResponse>
}

//
// Schema types
=======
// sequence-api v0.4.0 d43a5aac616814072c69e63f2f81fe65ea10a7e0
// --
// Code generated by webrpc-gen@v0.25.3 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=typescript -client -out=./clients/api.gen.ts

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.25.3;gen-typescript@v0.17.0;sequence-api@v0.4.0'

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = 'd43a5aac616814072c69e63f2f81fe65ea10a7e0'

type WebrpcGenVersions = {
  webrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  const [_, webrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    webrpcGenVersion: webrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? '',
  }
}

//
// Types
>>>>>>> Stashed changes
//

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC',
}

<<<<<<< Updated upstream
=======
export enum SardinePaymentType {
  ach = 'ach',
  debit = 'debit',
  credit = 'credit',
  us_debit = 'us_debit',
  international_debit = 'international_debit',
  international_credit = 'international_credit',
}

export enum SardineQuoteType {
  buy = 'buy',
  sell = 'sell',
}

>>>>>>> Stashed changes
export enum GetLifiSwapRouteDirection {
  to = 'to',
  from = 'from',
}

export enum TokenType {
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
}

export enum TransakBuySell {
  UNKNOWN = 'UNKNOWN',
  BUY = 'BUY',
  SELL = 'SELL',
}

export enum TradeType {
  EXACT_INPUT = 'EXACT_INPUT',
  EXACT_OUTPUT = 'EXACT_OUTPUT',
}

export enum CheckoutOptionCrypto {
  none = 'none',
  partially = 'partially',
  all = 'all',
}

export enum CheckoutOptionNFTCheckoutProvider {
  unknown = 'unknown',
<<<<<<< Updated upstream
=======
  sardine = 'sardine',
>>>>>>> Stashed changes
  transak = 'transak',
}

export enum CheckoutOptionOnRampProvider {
  unknown = 'unknown',
<<<<<<< Updated upstream
=======
  sardine = 'sardine',
>>>>>>> Stashed changes
  transak = 'transak',
}

export enum CheckoutOptionSwapProvider {
  unknown = 'unknown',
  lifi = 'lifi',
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  checks: RuntimeChecks
  numTxnsRelayed: { [key: string]: NumTxnsRelayed }
}

export interface NumTxnsRelayed {
  chainID: number
  prev: number
  current: number
  period: number
}

export interface RuntimeChecks {}

export interface SequenceContext {
  factory: string
  mainModule: string
  mainModuleUpgradable: string
  guestModule: string
  utils: string
}

export interface PublicKey {
  id: string
  x: string
  y: string
}

export interface User {
  address: string
  username: string
  avatar: string
  bio: string
  location: string
  locale: string
  backup?: boolean
  backupConfirmed?: boolean
  maxInvites?: number
  updatedAt?: string
  createdAt?: string
}

export interface WalletBackup {
  accountAddress: string
  secretHash: string
  encryptedWallet: string
  userConfirmed: boolean
  updatedAt?: string
  createdAt?: string
}

export interface Friend {
  id: number
  userAddress: string
  friendAddress: string
  nickname: string
  user?: User
  createdAt?: string
}

export interface MetaTxn {
  id: string
  chainId: string
  walletAddress: string
  contract: string
  input: string
}

export interface Call {
  to: string
  value?: string
  data?: string
  gasLimit?: string
  delegateCall?: boolean
  onlyFallback?: boolean
  behaviorOnError?: number
}

export interface IntentCallsPayload {
  chainId: string
  space?: string
  nonce?: string
  calls: Array<Call>
}

export interface IntentConfig {
  id: number
  configHash: string
  originIntentAddress: string
  destinationIntentAddress: string
  mainSigner: string
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  executionStatus?: string
  metaTxnId?: string
  txnHash?: string
  updatedAt?: string
  createdAt?: string
}

export interface MetaTxnReceipt {
  metaTxID: string
  status: string
  txnReceipt?: string
  revertReason?: string
}

export interface InviteCode {
  usesLeft: number
  ownerAccount: string
  email?: string
  url: string
  createdAt?: string
  expiresAt?: string
}

export interface InviteCodeAccount {
  claimedByUserAddress: string
  claimedAt?: string
}

export interface InviteInfo {
  expiryInHours: number
  max: number
  invites: Array<InviteCode>
}

export interface ContractCall {
  signature: string
  function: string
  args: Array<TupleComponent>
}

export interface TupleComponent {
  name?: string
  type: string
  value: any
}

export interface AddressOverrides {
  trailsLiFiSapientSignerAddress?: string
  trailsRelaySapientSignerAddress?: string
  trailsCCTPV2SapientSignerAddress?: string
}

export interface TakerFee {
  address: string
  bps: number
}

export interface OriginCall {
  chainId: number
  to: string
  transactionData: string
  transactionValue: string
}

export interface IntentPrecondition {
  type: string
  chainId: string
  data: any
}

export interface UserStorage {
  userAddress: string
  key: string
  value: any
}

export interface Token {
  chainId: number
  contractAddress: string
  tokenId?: string
}

export interface Price {
  value: number
  currency: string
}

export interface TokenPrice {
  token: Token
  price?: Price
  price24hChange?: Price
  price24hVol?: Price
  floorPrice: Price
  buyPrice: Price
  sellPrice: Price
  updatedAt: string
}

export interface ExchangeRate {
  name: string
  symbol: string
  value: number
  vsCurrency: string
  currencyType: string
}

export interface LinkedWallet {
  id: number
  walletType?: string
  walletAddress: string
  linkedWalletAddress: string
  createdAt?: string
}

export interface Page {
  pageSize?: number
  page?: number
  totalRecords?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  more?: boolean
}

export interface SortBy {
  column: string
  order: SortOrder
}

<<<<<<< Updated upstream
=======
export interface SardineNFTCheckoutParams {
  name: string
  imageUrl: string
  network: string
  recipientAddress: string
  blockchainNftId: string
  contractAddress: string
  quantity: number
  decimals?: number
  tokenAmount: string
  tokenAddress: string
  tokenSymbol: string
  tokenDecimals?: number
  calldata: string
  platform: string
  approvedSpenderAddress?: string
}

export interface SardineNFTCheckout {
  token: string
  expiresAt: string
  orderId: string
}

export interface SardineOrder {
  id: string
  createdAt?: string
  referenceId: string
  status: string
  fiatCurrency: string
  fiatExchangeRateUSD: number
  transactionId: string
  expiresAt?: string
  total: number
  subTotal: number
  transactionFee: number
  networkFee: number
  paymentCurrency?: string
  paymentMethodType?: string
  transactionType: string
  name: string
  price: number
  imageUrl: string
  contractAddress?: string
  transactionHash?: string
  recipientAddress: string
}

export interface SardineRegion {
  countryCode: string
  isAllowedOnRamp: boolean
  isAllowedOnNFT: boolean
  isBasicKycRequired: Array<string>
  isSsnRequired: Array<string>
  name: string
  currencyCode: string
  isPayrollSupported: boolean
  supportedDocuments: Array<string>
  paymentMethods: Array<SardineRegionPaymentMethod>
  states: Array<SardineRegionState>
}

export interface SardineRegionPaymentMethod {
  name: string
  isAllowedOnRamp: boolean
  isAllowedOnNFT: boolean
  subTypes: Array<string>
  type: string
  subType: string
}

export interface SardineRegionState {
  code: string
  name: string
  isAllowedOnRamp: boolean
  isAllowedOnNFT: boolean
}

export interface SardineSupportedToken {
  network: string
  assetSymbol: string
  assetName: string
  chainId: string
  tokenName: string
  token: string
  tokenAddress: string
}

export interface SardineSupportedTokenForSwap {
  isSupported: boolean
  isSupportedForAbstraction: boolean
  currentBalance: string
}

export interface SardineEnabledToken {
  network: string
  assetSymbol: string
  assetName: string
  chainId: string
  tokenName: string
  token: string
  tokenAddress: string
}

export interface SardineGetQuoteParams {
  assetType: string
  network: string
  total: number
  currency?: string
  paymentType?: SardinePaymentType
  quoteType?: SardineQuoteType
  walletAddress?: string
}

export interface SardineQuote {
  quantity: number
  network: string
  assetType: string
  total: number
  currency: string
  expiresAt: string
  paymentType: string
  price: number
  subtotal: number
  transactionFee: number
  networkFee: number
  highNetworkFee: boolean
  minTransactionValue: number
  maxTransactionValue: number
  liquidityProvider: string
}

export interface SardineFiatCurrency {
  currencyCode: string
  name: string
  currencySymbol: string
  paymentOptions: Array<SardinePaymentOption>
  supportingCountries: Array<string>
}

export interface SardinePaymentOption {
  name: string
  dailyLimit: number
  weeklyLimit: number
  monthlyLimit: number
  maxAmount: number
  minAmount: number
  subTypes: Array<string>
  type: string
  subType: string
  processingTime: string
}

>>>>>>> Stashed changes
export interface LifiToken {
  chainId: number
  address: string
  symbol: string
  name: string
  decimals: number
  priceUsd: number
  price?: string
  coinKey: string
  logoUri: string
}

export interface GetLifiSwapRouteParams {
  direction: GetLifiSwapRouteDirection
  chainId: number
  walletAddress: string
  tokenAddress: string
  tokenAmount: string
}

export interface LifiSwapRoute {
  fromChainId: number
  toChainId: number
  fromTokens: Array<LifiToken>
  toTokens: Array<LifiToken>
}

export interface GetLifiSwapQuoteParams {
  chainId: number
  walletAddress: string
  fromTokenAddress: string
  toTokenAddress: string
  fromTokenAmount?: string
  toTokenAmount?: string
  includeApprove: boolean
  slippageBps: number
}

export interface LifiSwapQuote {
  currencyAddress: string
  currencyBalance: string
  price: string
  maxPrice: string
  to: string
  transactionData: string
  transactionValue: string
  approveData: string
  amount: string
  amountMin: string
}

export interface CurrencyGroup {
  name: string
  tokens: Array<CurrencyGroupToken>
}

export interface CurrencyGroupToken {
  chainId: number
  tokenAddress: string
}

export interface OffchainInventory {
  id: number
  projectId: number
  chainId: number
  externalProductId: string
  paymentTokenAddress: string
  paymentTokenType: TokenType
  paymentTokenId: number
  paymentAmount: number
  paymentRecipient: string
  chainedCallAddress?: string
  chainedCallData?: string
  allowCrossChainPayments?: boolean
  callbackURL?: string
  createdAt: string
  deletedAt?: string
}

export interface CCTPTransfer {
  id: string
  sourceTxHash: string
  sourceChainId: number
  destinationChainId: number
  message: string
  attestation: string
  status: string
  createdAt: string
  updatedAt: string
}

export interface OffchainPayment {
  id: number
  offchainInventoryId: number
  productRecipient: string
  paymentChainId: number
  paymentTokenAddress: string
  expiration: string
  createdAt: string
  completedAt?: string
  processedAt?: string
}

export interface PaymentResponse {
  paymentId: number
  offchainInventoryId: number
  chainId: number
  externalProductId: string
  paymentTokenAddress: string
  paymentTokenType: TokenType
  paymentTokenId: number
  paymentTotal: number
  expiration: string
  signature: string
  txTo: string
  txData: string
}

export interface AdoptedChildWallet {
  address: string
}

export interface Pack {
  id: number
  chainId: number
  projectId: number
  contractAddress: string
  packId: string
  content: Array<PackContent>
  createdAt?: string
}

export interface PackContent {
  tokenAddresses: Array<string>
  isERC721: Array<boolean>
  tokenIds: Array<Array<string>>
  amounts: Array<Array<string>>
}

export interface TransakCountry {
  alpha2: string
  alpha3: string
  isAllowed: boolean
  isLightKycAllowed: boolean
  name: string
  currencyCode: string
  supportedDocuments: Array<string>
  partners: Array<TransakPartner>
  states: Array<TransakState>
}

export interface TransakPartner {
  name: string
  isCardPayment: boolean
  currencyCode: string
}

export interface TransakState {
  code: string
  name: string
  isAllowed: boolean
}

export interface TransakCryptoCurrency {
  id: string
  coinID: string
  address: string
  addressAdditionalData: any
  createdAt: string
  decimals: number
  image: TransakCryptoCurrencyImage
  isAllowed: boolean
  isPopular: boolean
  isStable: boolean
  name: string
  roundOff: number
  symbol: string
  isIgnorePriceVerification: boolean
  imageBk: TransakCryptoCurrencyImage
  kycCountriesNotSupported: Array<string>
  network: TransakCryptoCurrencyNetwork
  uniqueID: string
  tokenType: string
  tokenIdentifier: string
  isPayInAllowed: boolean
  isSuspended: boolean
}

export interface TransakCryptoCurrencyImage {
  large: string
  small: string
  thumb: string
}

export interface TransakCryptoCurrencyNetwork {
  name: string
  fiatCurrenciesNotSupported: Array<any>
  chainID: string
}

export interface TransakCryptoCurrencyNetworkFiatNotSupported {
  fiatCurrency: string
  paymentMethod: string
}

export interface TransakFiatCurrency {
  symbol: string
  supportingCountries: Array<string>
  logoSymbol: string
  name: string
  paymentOptions: Array<TransakFiatCurrencyPaymentOption>
  isPopular: boolean
  isAllowed: boolean
  roundOff: number
  isPayOutAllowed: boolean
  defaultCountryForNFT: string
  icon: string
  displayMessage: string
}

export interface TransakFiatCurrencyPaymentOption {
  name: string
  id: string
  isNftAllowed: boolean
  isNonCustodial: boolean
  processingTime: string
  displayText: boolean
  icon: string
  limitCurrency: string
  isActive: boolean
  provider: string
  maxAmount: number
  minAmount: number
  defaultAmount: number
  isConverted: boolean
  visaPayoutCountries: Array<string>
  mastercardPayoutCountries: Array<string>
  isPayOutAllowed: boolean
  minAmountForPayOut: number
  maxAmountForPayOut: number
  defaultAmountForPayOut: number
}

export interface TransakPrice {
  quoteID: string
  conversionPrice: number
  marketConversionPrice: number
  slippage: number
  fiatCurrency: string
  cryptoCurrency: string
  paymentMethod: string
  fiatAmount: number
  cryptoAmount: number
  isBuyOrSell: string
  network: string
  feeDecimal: number
  totalFee: number
  feeBreakdown: Array<TransakPriceFeeBreakdown>
  nonce: number
  cryptoLiquidityProvider: string
  notes: Array<any>
}

export interface TransakPriceFeeBreakdown {
  Name: string
  Value: number
  ID: string
  Ids: Array<string>
}

export interface TransakGetPriceParams {
  fiatCurrency: string
  cryptoCurrency: string
  isBuyOrSell: TransakBuySell
  network: string
  paymentMethod: string
  fiatAmount: number
  cryptoAmount: number
  quoteCountryCode: string
}

<<<<<<< Updated upstream
export interface TransakNFTData {
  imageUrl: string
  nftName: string
  collectionAddress: string
  tokenIds: Array<string>
  prices: Array<number>
  quantity: number
  nftType: string
}

export interface TransakGetWidgetURLParams {
  targetContractAddress?: string
  isNft?: boolean
  calldata?: string
  cryptoCurrencyCode?: string
  estimatedGasLimit?: number
  nftData: Array<TransakNFTData>
  walletAddress?: string
  disableWalletAddressForm?: boolean
  partnerOrderId?: string
  network?: string
  referrerDomain?: string
  fiatAmount?: string
  fiatCurrency?: string
  defaultFiatAmount?: string
  defaultCryptoCurrency?: string
  cryptoCurrencyList?: string
  networks?: string
}

=======
>>>>>>> Stashed changes
export interface TransakChain {
  name: string
  chainId: number
}

export interface CheckoutOptionsPrimaryParams {
  quantity: string
  tokenId: string
}

export interface CheckoutOptionsSecondaryParams {
  collectionAddress: string
  marketplaceAddress: string
  currencyAddress: string
  priceAmount: string
  tokenId: string
}

export interface CheckoutOptions {
  crypto: CheckoutOptionCrypto
  swap: Array<CheckoutOptionSwapProvider>
  nftCheckout: Array<CheckoutOptionNFTCheckoutProvider>
  onRamp: Array<CheckoutOptionOnRampProvider>
}

export interface FortePayCreateIntent {
  blockchain: string
  buyer: FortePayBuyer
  currency: string
  idempotencyKey: string
  items: Array<FortePayItem>
  seller: FortePaySeller
  transactionType: string
}

export interface FortePayBuyer {
  wallet: FortePayWallet
  email: string
  id: string
}

export interface FortePaySeller {
  wallet: FortePayWallet
}

export interface FortePayWallet {
  address: string
  blockchain: string
}

export interface FortePayItem {
  amount: string
  id: string
  imageUrl: string
  listingData: FortePayItemListingData
  nftData: FortePayItemNFTData
  mintData: FortePayItemMintData
  title: string
}

export interface FortePayItemListingData {
  orderHash: string
  protocol: string
  protocolAddress: string
  auctionHouse: string
  tokenAddress: string
  calldata: string
  payToAddress: string
  structuredCalldata: any
}

export interface FortePayItemNFTData {
  contractAddress: string
  tokenId: string
}

export interface FortePayItemMintData {
  nonce: string
  protocol: string
  protocolAddress: string
  signature: string
  tokenIds: Array<string>
  calldata: string
  payToAddress: string
  tokenContractAddress: string
  structuredCalldata: any
}

export interface FortePayIntent {
  flow: string
  widgetData: string
  paymentIntentId: string
  notes: Array<string>
}

export interface FortePaymentStatus {
  paymentIntentId: string
  status: string
}

export interface CrossChainFee {
  providerFee: string
  trailsSwapFee: string
  providerFeeUSD: number
  trailsSwapFeeUSD: number
  totalFeeAmount: string
  totalFeeUSD: number
}

export interface MetaTxnFeeDetail {
  metaTxnID: string
  estimatedGasLimit: string
  feeNative: string
}

export interface ChainExecuteQuote {
  chainId: string
  totalGasLimit: string
  gasPrice: string
  totalFeeAmount: string
  nativeTokenSymbol: string
  nativeTokenPrice?: string
  metaTxnFeeDetails: Array<MetaTxnFeeDetail>
  totalFeeUSD?: string
}

export interface ExecuteQuote {
  chainQuotes: Array<ChainExecuteQuote>
}

export interface TrailsFee {
  executeQuote: ExecuteQuote
  crossChainFee?: CrossChainFee
  takerFeeAmount?: string
  takerFeeUSD?: number
  trailsFixedFeeUSD: number
  feeToken?: string
  originTokenTotalAmount?: string
  totalFeeAmount?: string
  totalFeeUSD?: string
  quoteProvider?: string
}

export interface IntentQuote {
  fromAmount: string
  fromAmountMin: string
  toAmount: string
  toAmountMin: string
  priceImpact: number
  priceImpactUsd: string
  maxSlippage: number
  quoteProvider: string
  quoteProviderRequestId: string
  quoteProviderFeeUsd: string
  feeQuotes: { [key: string]: string }
}

<<<<<<< Updated upstream
export interface PingRequest {}

export interface PingResponse {
  status: boolean
}

export interface VersionRequest {}

export interface VersionResponse {
  version: Version
}

export interface RuntimeStatusRequest {}

export interface RuntimeStatusResponse {
  status: RuntimeStatus
}

export interface ClockRequest {}

export interface ClockResponse {
  serverTime: string
}

export interface GetSequenceContextRequest {}

export interface GetSequenceContextResponse {
  data: SequenceContext
}

export interface GetAuthTokenRequest {
=======
export interface API {
  /**
   *
   * Runtime
   *
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>
  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>
  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>
  clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>
  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>
  /**
   *
   * Auth
   *
   * TODO: rename 'ewtString' arg to 'ethauthProof'
   */
  getAuthToken(args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn>
  getAuthToken2(args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return>
  sendPasswordlessLink(
    args: SendPasswordlessLinkArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SendPasswordlessLinkReturn>
  registerPublicKey(
    args: RegisterPublicKeyArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RegisterPublicKeyReturn>
  getPublicKey(args: GetPublicKeyArgs, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyReturn>
  /**
   *
   * Contacts / Friends
   *
   */
  friendList(args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn>
  getFriendByAddress(
    args: GetFriendByAddressArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetFriendByAddressReturn>
  searchFriends(args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn>
  addFriend(args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn>
  updateFriendNickname(
    args: UpdateFriendNicknameArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateFriendNicknameReturn>
  removeFriend(args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn>
  /**
   *
   * Chain-Utils
   *
   */
  contractCall(args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn>
  decodeContractCall(
    args: DecodeContractCallArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DecodeContractCallReturn>
  lookupContractCallSelectors(
    args: LookupContractCallSelectorsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<LookupContractCallSelectorsReturn>
  /**
   *
   * User Storage
   *
   */
  userStorageFetch(args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchReturn>
  userStorageSave(args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveReturn>
  userStorageDelete(
    args: UserStorageDeleteArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageDeleteReturn>
  userStorageFetchAll(
    args: UserStorageFetchAllArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchAllReturn>
  /**
   *
   * Wallet utils
   *
   */
  getMoonpayLink(args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkReturn>
  /**
   * - IsUsingGoogleMail(domain: string) => (yes: bool)
   */
  resolveENSAddress(
    args: ResolveENSAddressArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ResolveENSAddressReturn>
  /**
   * TODO: we can add walletContext optional in the future when we need it
   * NOTE: chainId can be either a number or canonical name
   */
  isValidSignature(args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureReturn>
  isValidMessageSignature(
    args: IsValidMessageSignatureArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidMessageSignatureReturn>
  isValidTypedDataSignature(
    args: IsValidTypedDataSignatureArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidTypedDataSignatureReturn>
  isValidETHAuthProof(
    args: IsValidETHAuthProofArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidETHAuthProofReturn>
  getOnRampURL(args: GetOnRampURLArgs, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLReturn>
  sardineGetClientToken(headers?: object, signal?: AbortSignal): Promise<SardineGetClientTokenReturn>
  sardineGetNFTCheckoutToken(
    args: SardineGetNFTCheckoutTokenArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetNFTCheckoutTokenReturn>
  sardineGetNFTCheckoutOrderStatus(
    args: SardineGetNFTCheckoutOrderStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetNFTCheckoutOrderStatusReturn>
  sardineGetSupportedRegions(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedRegionsReturn>
  sardineGetSupportedFiatCurrencies(
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetSupportedFiatCurrenciesReturn>
  sardineGetSupportedTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedTokensReturn>
  sardineGetSupportedTokenForSwap(
    args: SardineGetSupportedTokenForSwapArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetSupportedTokenForSwapReturn>
  sardineGetEnabledTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetEnabledTokensReturn>
  sardineGetQuote(args: SardineGetQuoteArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetQuoteReturn>
  /**
   * Deprecated. Use SardineGetClientToken() instead.
   */
  getSardineClientToken(headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn>
  /**
   * Deprecated. Use SardineGetNFTCheckoutToken() instead.
   */
  getSardineNFTCheckoutToken(
    args: GetSardineNFTCheckoutTokenArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetSardineNFTCheckoutTokenReturn>
  /**
   * Deprecated. Use SardineGetNFTCheckoutOrderStatus() instead.
   */
  getSardineNFTCheckoutOrderStatus(
    args: GetSardineNFTCheckoutOrderStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetSardineNFTCheckoutOrderStatusReturn>
  transakGetCountries(headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesReturn>
  transakGetCryptoCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetCryptoCurrenciesReturn>
  transakGetFiatCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesReturn>
  transakGetPrice(args: TransakGetPriceArgs, headers?: object, signal?: AbortSignal): Promise<TransakGetPriceReturn>
  transakGetSupportedNFTCheckoutChains(
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetSupportedNFTCheckoutChainsReturn>
  /**
   *
   * Price Feed
   *
   */
  getCoinPrices(args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn>
  getCollectiblePrices(
    args: GetCollectiblePricesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCollectiblePricesReturn>
  /**
   *
   * Price Feed utils
   *
   */
  getExchangeRate(args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateReturn>
  /**
   *
   * Util / misc
   *
   */
  memoryStore(args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn>
  memoryLoad(args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn>
  /**
   *
   * Legacy
   *
   */
  getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn>
  /**
   * NOTE: we're still using this from SW-API to Sequence-API to claim invite code
   */
  isValidAccessCode(
    args: IsValidAccessCodeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidAccessCodeReturn>
  internalClaimAccessCode(
    args: InternalClaimAccessCodeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<InternalClaimAccessCodeReturn>
  /**
   * Utils
   */
  blockNumberAtTime(
    args: BlockNumberAtTimeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<BlockNumberAtTimeReturn>
  /**
   *
   * Paper
   * TODO: deprecate in the future
   *
   */
  paperSessionSecret(
    args: PaperSessionSecretArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecretReturn>
  paperSessionSecret2(
    args: PaperSessionSecret2Args,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecret2Return>
  /**
   *
   * Linked wallets (v0 -- simple support)
   *
   */
  linkWallet(args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn>
  getLinkedWallets(args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsReturn>
  removeLinkedWallet(
    args: RemoveLinkedWalletArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveLinkedWalletReturn>
  /**
   * NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
   * to be clear, they are not necessary for our linked wallets.
   */
  generateWaaSVerificationURL(
    args: GenerateWaaSVerificationURLArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GenerateWaaSVerificationURLReturn>
  validateWaaSVerificationNonce(
    args: ValidateWaaSVerificationNonceArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ValidateWaaSVerificationNonceReturn>
  /**
   *
   *
   * WaaS child wallet adoption
   *
   */
  listAdoptedWallets(
    args: ListAdoptedWalletsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListAdoptedWalletsReturn>
  getLifiChains(headers?: object, signal?: AbortSignal): Promise<GetLifiChainsReturn>
  getLifiTokens(args: GetLifiTokensArgs, headers?: object, signal?: AbortSignal): Promise<GetLifiTokensReturn>
  /**
   * All parameters except `params` are deprecated.
   * Use only the `params` object to pass values.
   */
  getLifiSwapRoutes(
    args: GetLifiSwapRoutesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapRoutesReturn>
  getLifiSwapQuote(args: GetLifiSwapQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetLifiSwapQuoteReturn>
  /**
   *
   * Chain abstraction
   *
   */
  getIntentCallsPayloads(
    args: GetIntentCallsPayloadsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentCallsPayloadsReturn>
  commitIntentConfig(
    args: CommitIntentConfigArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CommitIntentConfigReturn>
  getIntentConfig(args: GetIntentConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetIntentConfigReturn>
  /**
   *
   * Inventory, payments and management
   *
   */
  listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn>
  addOffchainInventory(
    args: AddOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddOffchainInventoryReturn>
  getOffchainInventory(
    args: GetOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetOffchainInventoryReturn>
  listOffchainInventories(
    args: ListOffchainInventoriesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainInventoriesReturn>
  updateOffchainInventory(
    args: UpdateOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateOffchainInventoryReturn>
  deleteOffchainInventory(
    args: DeleteOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteOffchainInventoryReturn>
  requestOffchainPayment(
    args: RequestOffchainPaymentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RequestOffchainPaymentReturn>
  listOffchainPayments(
    args: ListOffchainPaymentsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainPaymentsReturn>
  /**
   *
   * Packs
   *
   */
  savePack(args: SavePackArgs, headers?: object, signal?: AbortSignal): Promise<SavePackReturn>
  getPack(args: GetPackArgs, headers?: object, signal?: AbortSignal): Promise<GetPackReturn>
  getPackIds(args: GetPackIdsArgs, headers?: object, signal?: AbortSignal): Promise<GetPackIdsReturn>
  deletePack(args: DeletePackArgs, headers?: object, signal?: AbortSignal): Promise<DeletePackReturn>
  updatePackContent(
    args: UpdatePackContentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdatePackContentReturn>
  getRevealTxData(args: GetRevealTxDataArgs, headers?: object, signal?: AbortSignal): Promise<GetRevealTxDataReturn>
  checkoutOptionsPrimary(
    args: CheckoutOptionsPrimaryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsPrimaryReturn>
  checkoutOptionsSecondary(
    args: CheckoutOptionsSecondaryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsSecondaryReturn>
  checkoutOptionsGetTransakContractID(
    args: CheckoutOptionsGetTransakContractIDArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsGetTransakContractIDReturn>
  fortePayCreateIntent(
    args: FortePayCreateIntentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayCreateIntentReturn>
  fortePayGetPaymentStatuses(
    args: FortePayGetPaymentStatusesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayGetPaymentStatusesReturn>
  /**
   *
   * CCTP
   *
   */
  getCCTPTransfer(args: GetCCTPTransferArgs, headers?: object, signal?: AbortSignal): Promise<GetCCTPTransferReturn>
  queueCCTPTransfer(
    args: QueueCCTPTransferArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueCCTPTransferReturn>
  /**
   *
   * Intent Machine Worker
   *
   */
  queueIntentConfigExecution(
    args: QueueIntentConfigExecutionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueIntentConfigExecutionReturn>
  getIntentConfigExecutionStatus(
    args: GetIntentConfigExecutionStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigExecutionStatusReturn>
  listIntentConfigs(
    args: ListIntentConfigsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListIntentConfigsReturn>
  queueMetaTxnReceipt(
    args: QueueMetaTxnReceiptArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueMetaTxnReceiptReturn>
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}
export interface ClockArgs {}

export interface ClockReturn {
  serverTime: string
}
export interface GetSequenceContextArgs {}

export interface GetSequenceContextReturn {
  data: SequenceContext
}
export interface GetAuthTokenArgs {
>>>>>>> Stashed changes
  ewtString: string
  testnetMode?: boolean
}

<<<<<<< Updated upstream
export interface GetAuthTokenResponse {
=======
export interface GetAuthTokenReturn {
>>>>>>> Stashed changes
  status: boolean
  jwtToken: string
  address: string
  user?: User
}
<<<<<<< Updated upstream

export interface GetAuthToken2Request {
=======
export interface GetAuthToken2Args {
>>>>>>> Stashed changes
  ewtString: string
  chainID: string
}

<<<<<<< Updated upstream
export interface GetAuthToken2Response {
=======
export interface GetAuthToken2Return {
>>>>>>> Stashed changes
  status: boolean
  jwtToken: string
  address: string
  user?: User
}
<<<<<<< Updated upstream

export interface SendPasswordlessLinkRequest {
=======
export interface SendPasswordlessLinkArgs {
>>>>>>> Stashed changes
  email: string
  redirectUri: string
  intent: string
}

<<<<<<< Updated upstream
export interface SendPasswordlessLinkResponse {
  status: boolean
}

export interface RegisterPublicKeyRequest {
  publicKey: PublicKey
}

export interface RegisterPublicKeyResponse {
  status: boolean
}

export interface GetPublicKeyRequest {
  id: string
}

export interface GetPublicKeyResponse {
  publicKey: PublicKey
}

export interface FriendListRequest {
=======
export interface SendPasswordlessLinkReturn {
  status: boolean
}
export interface RegisterPublicKeyArgs {
  publicKey: PublicKey
}

export interface RegisterPublicKeyReturn {
  status: boolean
}
export interface GetPublicKeyArgs {
  id: string
}

export interface GetPublicKeyReturn {
  publicKey: PublicKey
}
export interface FriendListArgs {
>>>>>>> Stashed changes
  nickname?: string
  page?: Page
}

<<<<<<< Updated upstream
export interface FriendListResponse {
  page: Page
  friends: Array<Friend>
}

export interface GetFriendByAddressRequest {
  friendAddress: string
}

export interface GetFriendByAddressResponse {
  status: boolean
  friend: Friend
}

export interface SearchFriendsRequest {
=======
export interface FriendListReturn {
  page: Page
  friends: Array<Friend>
}
export interface GetFriendByAddressArgs {
  friendAddress: string
}

export interface GetFriendByAddressReturn {
  status: boolean
  friend: Friend
}
export interface SearchFriendsArgs {
>>>>>>> Stashed changes
  filterUsername: string
  page?: Page
}

<<<<<<< Updated upstream
export interface SearchFriendsResponse {
  friends: Array<Friend>
}

export interface AddFriendRequest {
=======
export interface SearchFriendsReturn {
  friends: Array<Friend>
}
export interface AddFriendArgs {
>>>>>>> Stashed changes
  friendAddress: string
  optionalNickname?: string
}

<<<<<<< Updated upstream
export interface AddFriendResponse {
  status: boolean
  friend?: Friend
}

export interface UpdateFriendNicknameRequest {
=======
export interface AddFriendReturn {
  status: boolean
  friend?: Friend
}
export interface UpdateFriendNicknameArgs {
>>>>>>> Stashed changes
  friendAddress: string
  nickname: string
}

<<<<<<< Updated upstream
export interface UpdateFriendNicknameResponse {
  status: boolean
  friend?: Friend
}

export interface RemoveFriendRequest {
  friendAddress: string
}

export interface RemoveFriendResponse {
  status: boolean
}

export interface ContractCallRequest {
=======
export interface UpdateFriendNicknameReturn {
  status: boolean
  friend?: Friend
}
export interface RemoveFriendArgs {
  friendAddress: string
}

export interface RemoveFriendReturn {
  status: boolean
}
export interface ContractCallArgs {
>>>>>>> Stashed changes
  chainID: string
  contract: string
  inputExpr: string
  outputExpr: string
  args: Array<string>
}

<<<<<<< Updated upstream
export interface ContractCallResponse {
  returns: Array<string>
}

export interface DecodeContractCallRequest {
  callData: string
}

export interface DecodeContractCallResponse {
  call: ContractCall
}

export interface LookupContractCallSelectorsRequest {
  selectors: Array<string>
}

export interface LookupContractCallSelectorsResponse {
  signatures: Array<Array<string>>
}

export interface UserStorageFetchRequest {
  key: string
}

export interface UserStorageFetchResponse {
  object: any
}

export interface UserStorageSaveRequest {
=======
export interface ContractCallReturn {
  returns: Array<string>
}
export interface DecodeContractCallArgs {
  callData: string
}

export interface DecodeContractCallReturn {
  call: ContractCall
}
export interface LookupContractCallSelectorsArgs {
  selectors: Array<string>
}

export interface LookupContractCallSelectorsReturn {
  signatures: Array<Array<string>>
}
export interface UserStorageFetchArgs {
  key: string
}

export interface UserStorageFetchReturn {
  object: any
}
export interface UserStorageSaveArgs {
>>>>>>> Stashed changes
  key: string
  object: any
}

<<<<<<< Updated upstream
export interface UserStorageSaveResponse {
  ok: boolean
}

export interface UserStorageDeleteRequest {
  key: string
}

export interface UserStorageDeleteResponse {
  ok: boolean
}

export interface UserStorageFetchAllRequest {
  keys?: Array<string>
}

export interface UserStorageFetchAllResponse {
  objects: { [key: string]: any }
}

export interface GetMoonpayLinkRequest {
  url: string
}

export interface GetMoonpayLinkResponse {
  signedUrl: string
}

export interface ResolveENSAddressRequest {
  ens: string
}

export interface ResolveENSAddressResponse {
  address: string
  ok: boolean
}

export interface IsValidSignatureRequest {
=======
export interface UserStorageSaveReturn {
  ok: boolean
}
export interface UserStorageDeleteArgs {
  key: string
}

export interface UserStorageDeleteReturn {
  ok: boolean
}
export interface UserStorageFetchAllArgs {
  keys?: Array<string>
}

export interface UserStorageFetchAllReturn {
  objects: { [key: string]: any }
}
export interface GetMoonpayLinkArgs {
  url: string
}

export interface GetMoonpayLinkReturn {
  signedUrl: string
}
export interface ResolveENSAddressArgs {
  ens: string
}

export interface ResolveENSAddressReturn {
  address: string
  ok: boolean
}
export interface IsValidSignatureArgs {
>>>>>>> Stashed changes
  chainId: string
  walletAddress: string
  digest: string
  signature: string
}

<<<<<<< Updated upstream
export interface IsValidSignatureResponse {
  isValid: boolean
}

export interface IsValidMessageSignatureRequest {
=======
export interface IsValidSignatureReturn {
  isValid: boolean
}
export interface IsValidMessageSignatureArgs {
>>>>>>> Stashed changes
  chainId: string
  walletAddress: string
  message: string
  signature: string
}

<<<<<<< Updated upstream
export interface IsValidMessageSignatureResponse {
  isValid: boolean
}

export interface IsValidTypedDataSignatureRequest {
=======
export interface IsValidMessageSignatureReturn {
  isValid: boolean
}
export interface IsValidTypedDataSignatureArgs {
>>>>>>> Stashed changes
  chainId: string
  walletAddress: string
  typedData: any
  signature: string
}

<<<<<<< Updated upstream
export interface IsValidTypedDataSignatureResponse {
  isValid: boolean
}

export interface IsValidETHAuthProofRequest {
=======
export interface IsValidTypedDataSignatureReturn {
  isValid: boolean
}
export interface IsValidETHAuthProofArgs {
>>>>>>> Stashed changes
  chainId: string
  walletAddress: string
  ethAuthProofString: string
}

<<<<<<< Updated upstream
export interface IsValidETHAuthProofResponse {
  isValid: boolean
}

export interface GetOnRampURLRequest {
  chainId: string
}

export interface GetOnRampURLResponse {
  url: string
}

export interface TransakGetCountriesRequest {}

export interface TransakGetCountriesResponse {
  regions: Array<TransakCountry>
}

export interface TransakGetCryptoCurrenciesRequest {}

export interface TransakGetCryptoCurrenciesResponse {
  currencies: Array<TransakCryptoCurrency>
}

export interface TransakGetFiatCurrenciesRequest {}

export interface TransakGetFiatCurrenciesResponse {
  currencies: Array<TransakFiatCurrency>
}

export interface TransakGetPriceRequest {
  params: TransakGetPriceParams
}

export interface TransakGetPriceResponse {
  price: TransakPrice
}

export interface TransakGetSupportedNFTCheckoutChainsRequest {}

export interface TransakGetSupportedNFTCheckoutChainsResponse {
  chains: Array<TransakChain>
}

export interface TransakGetWidgetURLRequest {
  params: TransakGetWidgetURLParams
}

export interface TransakGetWidgetURLResponse {
  url: string
}

export interface GetCoinPricesRequest {
  tokens: Array<Token>
}

export interface GetCoinPricesResponse {
  tokenPrices: Array<TokenPrice>
}

export interface GetCollectiblePricesRequest {
  tokens: Array<Token>
}

export interface GetCollectiblePricesResponse {
  tokenPrices: Array<TokenPrice>
}

export interface GetExchangeRateRequest {
  toCurrency: string
}

export interface GetExchangeRateResponse {
  exchangeRate: ExchangeRate
}

export interface MemoryStoreRequest {
=======
export interface IsValidETHAuthProofReturn {
  isValid: boolean
}
export interface GetOnRampURLArgs {
  chainId: string
}

export interface GetOnRampURLReturn {
  url: string
}
export interface SardineGetClientTokenArgs {}

export interface SardineGetClientTokenReturn {
  token: string
}
export interface SardineGetNFTCheckoutTokenArgs {
  params: SardineNFTCheckoutParams
}

export interface SardineGetNFTCheckoutTokenReturn {
  resp: SardineNFTCheckout
}
export interface SardineGetNFTCheckoutOrderStatusArgs {
  orderId: string
}

export interface SardineGetNFTCheckoutOrderStatusReturn {
  resp: SardineOrder
}
export interface SardineGetSupportedRegionsArgs {}

export interface SardineGetSupportedRegionsReturn {
  regions: Array<SardineRegion>
}
export interface SardineGetSupportedFiatCurrenciesArgs {}

export interface SardineGetSupportedFiatCurrenciesReturn {
  tokens: Array<SardineFiatCurrency>
}
export interface SardineGetSupportedTokensArgs {}

export interface SardineGetSupportedTokensReturn {
  tokens: Array<SardineSupportedToken>
}
export interface SardineGetSupportedTokenForSwapArgs {
  network: string
  tokenAddress: string
}

export interface SardineGetSupportedTokenForSwapReturn {
  token: SardineSupportedTokenForSwap
}
export interface SardineGetEnabledTokensArgs {}

export interface SardineGetEnabledTokensReturn {
  tokens: Array<SardineEnabledToken>
}
export interface SardineGetQuoteArgs {
  params: SardineGetQuoteParams
}

export interface SardineGetQuoteReturn {
  quote: SardineQuote
}
export interface GetSardineClientTokenArgs {}

export interface GetSardineClientTokenReturn {
  token: string
}
export interface GetSardineNFTCheckoutTokenArgs {
  params: SardineNFTCheckoutParams
}

export interface GetSardineNFTCheckoutTokenReturn {
  resp: SardineNFTCheckout
}
export interface GetSardineNFTCheckoutOrderStatusArgs {
  orderId: string
}

export interface GetSardineNFTCheckoutOrderStatusReturn {
  resp: SardineOrder
}
export interface TransakGetCountriesArgs {}

export interface TransakGetCountriesReturn {
  regions: Array<TransakCountry>
}
export interface TransakGetCryptoCurrenciesArgs {}

export interface TransakGetCryptoCurrenciesReturn {
  currencies: Array<TransakCryptoCurrency>
}
export interface TransakGetFiatCurrenciesArgs {}

export interface TransakGetFiatCurrenciesReturn {
  currencies: Array<TransakFiatCurrency>
}
export interface TransakGetPriceArgs {
  params: TransakGetPriceParams
}

export interface TransakGetPriceReturn {
  price: TransakPrice
}
export interface TransakGetSupportedNFTCheckoutChainsArgs {}

export interface TransakGetSupportedNFTCheckoutChainsReturn {
  chains: Array<TransakChain>
}
export interface GetCoinPricesArgs {
  tokens: Array<Token>
}

export interface GetCoinPricesReturn {
  tokenPrices: Array<TokenPrice>
}
export interface GetCollectiblePricesArgs {
  tokens: Array<Token>
}

export interface GetCollectiblePricesReturn {
  tokenPrices: Array<TokenPrice>
}
export interface GetExchangeRateArgs {
  toCurrency: string
}

export interface GetExchangeRateReturn {
  exchangeRate: ExchangeRate
}
export interface MemoryStoreArgs {
>>>>>>> Stashed changes
  key: string
  value: string
}

<<<<<<< Updated upstream
export interface MemoryStoreResponse {
  ok: boolean
}

export interface MemoryLoadRequest {
  key: string
}

export interface MemoryLoadResponse {
  value: string
}

export interface GetInviteInfoRequest {}

export interface GetInviteInfoResponse {
  inviteInfo: InviteInfo
}

export interface IsValidAccessCodeRequest {
  accessCode: string
}

export interface IsValidAccessCodeResponse {
  status: boolean
}

export interface InternalClaimAccessCodeRequest {
=======
export interface MemoryStoreReturn {
  ok: boolean
}
export interface MemoryLoadArgs {
  key: string
}

export interface MemoryLoadReturn {
  value: string
}
export interface GetInviteInfoArgs {}

export interface GetInviteInfoReturn {
  inviteInfo: InviteInfo
}
export interface IsValidAccessCodeArgs {
  accessCode: string
}

export interface IsValidAccessCodeReturn {
  status: boolean
}
export interface InternalClaimAccessCodeArgs {
>>>>>>> Stashed changes
  address: string
  accessCode: string
}

<<<<<<< Updated upstream
export interface InternalClaimAccessCodeResponse {
  status: boolean
}

export interface BlockNumberAtTimeRequest {
=======
export interface InternalClaimAccessCodeReturn {
  status: boolean
}
export interface BlockNumberAtTimeArgs {
>>>>>>> Stashed changes
  chainId: number
  timestamps: Array<number>
}

<<<<<<< Updated upstream
export interface BlockNumberAtTimeResponse {
  blocks: Array<number>
}

export interface PaperSessionSecretRequest {
=======
export interface BlockNumberAtTimeReturn {
  blocks: Array<number>
}
export interface PaperSessionSecretArgs {
>>>>>>> Stashed changes
  chainName: string
  contractAddress: string
  paramsJson: string
  contractType: string
}

<<<<<<< Updated upstream
export interface PaperSessionSecretResponse {
  secret: string
}

export interface PaperSessionSecret2Request {
=======
export interface PaperSessionSecretReturn {
  secret: string
}
export interface PaperSessionSecret2Args {
>>>>>>> Stashed changes
  chainName: string
  contractAddress: string
  paramsJson: string
  abi: string
}

<<<<<<< Updated upstream
export interface PaperSessionSecret2Response {
  secret: string
}

export interface LinkWalletRequest {
=======
export interface PaperSessionSecret2Return {
  secret: string
}
export interface LinkWalletArgs {
>>>>>>> Stashed changes
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  linkedWalletAddress: string
  linkedWalletMessage: string
  linkedWalletSignature: string
  signatureChainId: string
  linkedWalletType?: string
}

<<<<<<< Updated upstream
export interface LinkWalletResponse {
  status: boolean
}

export interface GetLinkedWalletsRequest {
=======
export interface LinkWalletReturn {
  status: boolean
}
export interface GetLinkedWalletsArgs {
>>>>>>> Stashed changes
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  signatureChainId: string
}

<<<<<<< Updated upstream
export interface GetLinkedWalletsResponse {
  linkedWallets: Array<LinkedWallet>
}

export interface RemoveLinkedWalletRequest {
=======
export interface GetLinkedWalletsReturn {
  linkedWallets: Array<LinkedWallet>
}
export interface RemoveLinkedWalletArgs {
>>>>>>> Stashed changes
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  linkedWalletAddress: string
  signatureChainId: string
}

<<<<<<< Updated upstream
export interface RemoveLinkedWalletResponse {
  status: boolean
}

export interface GenerateWaaSVerificationURLRequest {
  walletAddress: string
}

export interface GenerateWaaSVerificationURLResponse {
  nonce: string
  verificationURL: string
}

export interface ValidateWaaSVerificationNonceRequest {
=======
export interface RemoveLinkedWalletReturn {
  status: boolean
}
export interface GenerateWaaSVerificationURLArgs {
  walletAddress: string
}

export interface GenerateWaaSVerificationURLReturn {
  nonce: string
  verificationURL: string
}
export interface ValidateWaaSVerificationNonceArgs {
>>>>>>> Stashed changes
  nonce: string
  signature: string
  sessionId: string
  chainId: string
}

<<<<<<< Updated upstream
export interface ValidateWaaSVerificationNonceResponse {
  walletAddress: string
}

export interface ListAdoptedWalletsRequest {
  page?: Page
}

export interface ListAdoptedWalletsResponse {
  page: Page
  wallets: Array<AdoptedChildWallet>
}

export interface GetLifiChainsRequest {}

export interface GetLifiChainsResponse {
  chains: Array<number>
}

export interface GetLifiTokensRequest {
  chainIds: Array<number>
}

export interface GetLifiTokensResponse {
  tokens: Array<Token>
}

export interface GetLifiSwapRoutesRequest {
=======
export interface ValidateWaaSVerificationNonceReturn {
  walletAddress: string
}
export interface ListAdoptedWalletsArgs {
  page?: Page
}

export interface ListAdoptedWalletsReturn {
  page: Page
  wallets: Array<AdoptedChildWallet>
}
export interface GetLifiChainsArgs {}

export interface GetLifiChainsReturn {
  chains: Array<number>
}
export interface GetLifiTokensArgs {
  chainIds: Array<number>
}

export interface GetLifiTokensReturn {
  tokens: Array<Token>
}
export interface GetLifiSwapRoutesArgs {
>>>>>>> Stashed changes
  params: GetLifiSwapRouteParams
  chainId: number
  toTokenAddress: string
  toTokenAmount: string
  walletAddress: string
}

<<<<<<< Updated upstream
export interface GetLifiSwapRoutesResponse {
  routes: Array<LifiSwapRoute>
}

export interface GetLifiSwapQuoteRequest {
  params: GetLifiSwapQuoteParams
}

export interface GetLifiSwapQuoteResponse {
  quote: LifiSwapQuote
}

export interface GetIntentCallsPayloadsRequest {
=======
export interface GetLifiSwapRoutesReturn {
  routes: Array<LifiSwapRoute>
}
export interface GetLifiSwapQuoteArgs {
  params: GetLifiSwapQuoteParams
}

export interface GetLifiSwapQuoteReturn {
  quote: LifiSwapQuote
}
export interface GetIntentCallsPayloadsArgs {
>>>>>>> Stashed changes
  userAddress: string
  destinationChainId: number
  destinationTokenAddress: string
  destinationTokenAmount: string
  destinationToAddress: string
  originChainId: number
  originTokenAddress: string
  originTokenAmount: string
  destinationCallData?: string
  destinationCallValue?: string
  provider?: string
  addressOverrides?: AddressOverrides
  destinationSalt?: string
  takerFee?: TakerFee
  slippageTolerance?: number
  tradeType?: TradeType
}

<<<<<<< Updated upstream
export interface GetIntentCallsPayloadsResponse {
=======
export interface GetIntentCallsPayloadsReturn {
>>>>>>> Stashed changes
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  metaTxns: Array<MetaTxn>
  trailsFee: TrailsFee
  quote: IntentQuote
  feeQuotes: { [key: string]: string }
  originIntentAddress: string
  destinationIntentAddress: string
}
<<<<<<< Updated upstream

export interface CommitIntentConfigRequest {
=======
export interface CommitIntentConfigArgs {
>>>>>>> Stashed changes
  originIntentAddress: string
  destinationIntentAddress: string
  mainSigner: string
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  addressOverrides?: AddressOverrides
}

<<<<<<< Updated upstream
export interface CommitIntentConfigResponse {
  config: IntentConfig
}

export interface GetIntentConfigRequest {
  intentAddress: string
}

export interface GetIntentConfigResponse {
  config: IntentConfig
}

export interface ListCurrencyGroupsRequest {}

export interface ListCurrencyGroupsResponse {
  currencyGroups: Array<CurrencyGroup>
}

export interface AddOffchainInventoryRequest {
  inventory: OffchainInventory
}

export interface AddOffchainInventoryResponse {
  inventoryId: number
}

export interface GetOffchainInventoryRequest {
  inventoryId: number
}

export interface GetOffchainInventoryResponse {
  inventory: OffchainInventory
}

export interface ListOffchainInventoriesRequest {
  projectId: number
}

export interface ListOffchainInventoriesResponse {
  inventory: Array<OffchainInventory>
}

export interface UpdateOffchainInventoryRequest {
  inventory: OffchainInventory
}

export interface UpdateOffchainInventoryResponse {}

export interface DeleteOffchainInventoryRequest {
  inventoryId: number
}

export interface DeleteOffchainInventoryResponse {
  ok: boolean
}

export interface RequestOffchainPaymentRequest {
=======
export interface CommitIntentConfigReturn {
  config: IntentConfig
}
export interface GetIntentConfigArgs {
  intentAddress: string
}

export interface GetIntentConfigReturn {
  config: IntentConfig
}
export interface ListCurrencyGroupsArgs {}

export interface ListCurrencyGroupsReturn {
  currencyGroups: Array<CurrencyGroup>
}
export interface AddOffchainInventoryArgs {
  inventory: OffchainInventory
}

export interface AddOffchainInventoryReturn {
  inventoryId: number
}
export interface GetOffchainInventoryArgs {
  inventoryId: number
}

export interface GetOffchainInventoryReturn {
  inventory: OffchainInventory
}
export interface ListOffchainInventoriesArgs {
  projectId: number
}

export interface ListOffchainInventoriesReturn {
  inventory: Array<OffchainInventory>
}
export interface UpdateOffchainInventoryArgs {
  inventory: OffchainInventory
}

export interface UpdateOffchainInventoryReturn {}
export interface DeleteOffchainInventoryArgs {
  inventoryId: number
}

export interface DeleteOffchainInventoryReturn {
  ok: boolean
}
export interface RequestOffchainPaymentArgs {
>>>>>>> Stashed changes
  inventoryId: number
  recipient: string
  chainId?: number
  tokenAddress?: string
}

<<<<<<< Updated upstream
export interface RequestOffchainPaymentResponse {
  payment: PaymentResponse
}

export interface ListOffchainPaymentsRequest {
=======
export interface RequestOffchainPaymentReturn {
  payment: PaymentResponse
}
export interface ListOffchainPaymentsArgs {
>>>>>>> Stashed changes
  inventoryId: number
  page?: Page
}

<<<<<<< Updated upstream
export interface ListOffchainPaymentsResponse {
  page: Page
  payments: Array<OffchainPayment>
}

export interface SavePackRequest {
  pack: Pack
}

export interface SavePackResponse {
  merkleRoot: string
}

export interface GetPackRequest {
=======
export interface ListOffchainPaymentsReturn {
  page: Page
  payments: Array<OffchainPayment>
}
export interface SavePackArgs {
  pack: Pack
}

export interface SavePackReturn {
  merkleRoot: string
}
export interface GetPackArgs {
>>>>>>> Stashed changes
  contractAddress: string
  packId: string
  chainId: number
}

<<<<<<< Updated upstream
export interface GetPackResponse {
  pack: Pack
}

export interface GetPackIdsRequest {
=======
export interface GetPackReturn {
  pack: Pack
}
export interface GetPackIdsArgs {
>>>>>>> Stashed changes
  contractAddress: string
  chainId: number
}

<<<<<<< Updated upstream
export interface GetPackIdsResponse {
  packIds: Array<string>
}

export interface DeletePackRequest {
=======
export interface GetPackIdsReturn {
  packIds: Array<string>
}
export interface DeletePackArgs {
>>>>>>> Stashed changes
  contractAddress: string
  packId: string
  chainId: number
}

<<<<<<< Updated upstream
export interface DeletePackResponse {
  status: boolean
}

export interface UpdatePackContentRequest {
  pack: Pack
}

export interface UpdatePackContentResponse {
  merkleRoot: string
}

export interface GetRevealTxDataRequest {
=======
export interface DeletePackReturn {
  status: boolean
}
export interface UpdatePackContentArgs {
  pack: Pack
}

export interface UpdatePackContentReturn {
  merkleRoot: string
}
export interface GetRevealTxDataArgs {
>>>>>>> Stashed changes
  contractAddress: string
  packId: string
  chainId: number
  userAddress: string
}

<<<<<<< Updated upstream
export interface GetRevealTxDataResponse {
  txData: string
}

export interface CheckoutOptionsPrimaryRequest {
=======
export interface GetRevealTxDataReturn {
  txData: string
}
export interface CheckoutOptionsPrimaryArgs {
>>>>>>> Stashed changes
  chainId: number
  wallet: string
  contractAddress: string
  collectionAddress: string
  params: Array<CheckoutOptionsPrimaryParams>
}

<<<<<<< Updated upstream
export interface CheckoutOptionsPrimaryResponse {
  options: CheckoutOptions
}

export interface CheckoutOptionsSecondaryRequest {
=======
export interface CheckoutOptionsPrimaryReturn {
  options: CheckoutOptions
}
export interface CheckoutOptionsSecondaryArgs {
>>>>>>> Stashed changes
  chainId: number
  wallet: string
  params: Array<CheckoutOptionsSecondaryParams>
}

<<<<<<< Updated upstream
export interface CheckoutOptionsSecondaryResponse {
  options: CheckoutOptions
}

export interface CheckoutOptionsGetTransakContractIDRequest {
=======
export interface CheckoutOptionsSecondaryReturn {
  options: CheckoutOptions
}
export interface CheckoutOptionsGetTransakContractIDArgs {
>>>>>>> Stashed changes
  chainId: number
  contractAddress: string
}

<<<<<<< Updated upstream
export interface CheckoutOptionsGetTransakContractIDResponse {
  contractId: string
}

export interface FortePayCreateIntentRequest {
  intent: FortePayCreateIntent
}

export interface FortePayCreateIntentResponse {
  resp: FortePayIntent
}

export interface FortePayGetPaymentStatusesRequest {
  paymentIntentIds: Array<string>
}

export interface FortePayGetPaymentStatusesResponse {
  statuses: Array<FortePaymentStatus>
}

export interface GetCCTPTransferRequest {
  id: string
}

export interface GetCCTPTransferResponse {
  transfer: CCTPTransfer
}

export interface QueueCCTPTransferRequest {
=======
export interface CheckoutOptionsGetTransakContractIDReturn {
  contractId: string
}
export interface FortePayCreateIntentArgs {
  intent: FortePayCreateIntent
}

export interface FortePayCreateIntentReturn {
  resp: FortePayIntent
}
export interface FortePayGetPaymentStatusesArgs {
  paymentIntentIds: Array<string>
}

export interface FortePayGetPaymentStatusesReturn {
  statuses: Array<FortePaymentStatus>
}
export interface GetCCTPTransferArgs {
  id: string
}

export interface GetCCTPTransferReturn {
  transfer: CCTPTransfer
}
export interface QueueCCTPTransferArgs {
>>>>>>> Stashed changes
  sourceTxHash?: string
  metaTxHash?: string
  sourceChainId: number
  destinationChainId: number
}

<<<<<<< Updated upstream
export interface QueueCCTPTransferResponse {
  transfer: CCTPTransfer
}

export interface QueueIntentConfigExecutionRequest {
  intentConfigId: number
}

export interface QueueIntentConfigExecutionResponse {
  status: boolean
}

export interface GetIntentConfigExecutionStatusRequest {
  intentConfigId: number
}

export interface GetIntentConfigExecutionStatusResponse {
  executionStatus: string
}

export interface ListIntentConfigsRequest {
=======
export interface QueueCCTPTransferReturn {
  transfer: CCTPTransfer
}
export interface QueueIntentConfigExecutionArgs {
  intentConfigId: number
}

export interface QueueIntentConfigExecutionReturn {
  status: boolean
}
export interface GetIntentConfigExecutionStatusArgs {
  intentConfigId: number
}

export interface GetIntentConfigExecutionStatusReturn {
  executionStatus: string
}
export interface ListIntentConfigsArgs {
>>>>>>> Stashed changes
  page?: Page
  executionStatus?: string
}

<<<<<<< Updated upstream
export interface ListIntentConfigsResponse {
  page: Page
  intentConfigs: Array<IntentConfig>
}

export interface QueueMetaTxnReceiptRequest {
  metaTxID: string
}

export interface QueueMetaTxnReceiptResponse {
=======
export interface ListIntentConfigsReturn {
  page: Page
  intentConfigs: Array<IntentConfig>
}
export interface QueueMetaTxnReceiptArgs {
  metaTxID: string
}

export interface QueueMetaTxnReceiptReturn {
>>>>>>> Stashed changes
  status: boolean
}

//
// Client
//
<<<<<<< Updated upstream

export class API implements APIClient {
=======
export class API implements API {
>>>>>>> Stashed changes
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/API/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

<<<<<<< Updated upstream
  queryKey = {
    ping: () => ['API', 'ping'] as const,
    version: () => ['API', 'version'] as const,
    runtimeStatus: () => ['API', 'runtimeStatus'] as const,
    clock: () => ['API', 'clock'] as const,
    getSequenceContext: () => ['API', 'getSequenceContext'] as const,
    getAuthToken: (req: GetAuthTokenRequest) => ['API', 'getAuthToken', req] as const,
    getAuthToken2: (req: GetAuthToken2Request) => ['API', 'getAuthToken2', req] as const,
    sendPasswordlessLink: (req: SendPasswordlessLinkRequest) => ['API', 'sendPasswordlessLink', req] as const,
    registerPublicKey: (req: RegisterPublicKeyRequest) => ['API', 'registerPublicKey', req] as const,
    getPublicKey: (req: GetPublicKeyRequest) => ['API', 'getPublicKey', req] as const,
    friendList: (req: FriendListRequest) => ['API', 'friendList', req] as const,
    getFriendByAddress: (req: GetFriendByAddressRequest) => ['API', 'getFriendByAddress', req] as const,
    searchFriends: (req: SearchFriendsRequest) => ['API', 'searchFriends', req] as const,
    addFriend: (req: AddFriendRequest) => ['API', 'addFriend', req] as const,
    updateFriendNickname: (req: UpdateFriendNicknameRequest) => ['API', 'updateFriendNickname', req] as const,
    removeFriend: (req: RemoveFriendRequest) => ['API', 'removeFriend', req] as const,
    contractCall: (req: ContractCallRequest) => ['API', 'contractCall', req] as const,
    decodeContractCall: (req: DecodeContractCallRequest) => ['API', 'decodeContractCall', req] as const,
    lookupContractCallSelectors: (req: LookupContractCallSelectorsRequest) =>
      ['API', 'lookupContractCallSelectors', req] as const,
    userStorageFetch: (req: UserStorageFetchRequest) => ['API', 'userStorageFetch', req] as const,
    userStorageSave: (req: UserStorageSaveRequest) => ['API', 'userStorageSave', req] as const,
    userStorageDelete: (req: UserStorageDeleteRequest) => ['API', 'userStorageDelete', req] as const,
    userStorageFetchAll: (req: UserStorageFetchAllRequest) => ['API', 'userStorageFetchAll', req] as const,
    getMoonpayLink: (req: GetMoonpayLinkRequest) => ['API', 'getMoonpayLink', req] as const,
    resolveENSAddress: (req: ResolveENSAddressRequest) => ['API', 'resolveENSAddress', req] as const,
    isValidSignature: (req: IsValidSignatureRequest) => ['API', 'isValidSignature', req] as const,
    isValidMessageSignature: (req: IsValidMessageSignatureRequest) => ['API', 'isValidMessageSignature', req] as const,
    isValidTypedDataSignature: (req: IsValidTypedDataSignatureRequest) =>
      ['API', 'isValidTypedDataSignature', req] as const,
    isValidETHAuthProof: (req: IsValidETHAuthProofRequest) => ['API', 'isValidETHAuthProof', req] as const,
    getOnRampURL: (req: GetOnRampURLRequest) => ['API', 'getOnRampURL', req] as const,
    transakGetCountries: () => ['API', 'transakGetCountries'] as const,
    transakGetCryptoCurrencies: () => ['API', 'transakGetCryptoCurrencies'] as const,
    transakGetFiatCurrencies: () => ['API', 'transakGetFiatCurrencies'] as const,
    transakGetPrice: (req: TransakGetPriceRequest) => ['API', 'transakGetPrice', req] as const,
    transakGetSupportedNFTCheckoutChains: () => ['API', 'transakGetSupportedNFTCheckoutChains'] as const,
    transakGetWidgetURL: (req: TransakGetWidgetURLRequest) => ['API', 'transakGetWidgetURL', req] as const,
    getCoinPrices: (req: GetCoinPricesRequest) => ['API', 'getCoinPrices', req] as const,
    getCollectiblePrices: (req: GetCollectiblePricesRequest) => ['API', 'getCollectiblePrices', req] as const,
    getExchangeRate: (req: GetExchangeRateRequest) => ['API', 'getExchangeRate', req] as const,
    memoryStore: (req: MemoryStoreRequest) => ['API', 'memoryStore', req] as const,
    memoryLoad: (req: MemoryLoadRequest) => ['API', 'memoryLoad', req] as const,
    getInviteInfo: () => ['API', 'getInviteInfo'] as const,
    isValidAccessCode: (req: IsValidAccessCodeRequest) => ['API', 'isValidAccessCode', req] as const,
    internalClaimAccessCode: (req: InternalClaimAccessCodeRequest) => ['API', 'internalClaimAccessCode', req] as const,
    blockNumberAtTime: (req: BlockNumberAtTimeRequest) => ['API', 'blockNumberAtTime', req] as const,
    paperSessionSecret: (req: PaperSessionSecretRequest) => ['API', 'paperSessionSecret', req] as const,
    paperSessionSecret2: (req: PaperSessionSecret2Request) => ['API', 'paperSessionSecret2', req] as const,
    linkWallet: (req: LinkWalletRequest) => ['API', 'linkWallet', req] as const,
    getLinkedWallets: (req: GetLinkedWalletsRequest) => ['API', 'getLinkedWallets', req] as const,
    removeLinkedWallet: (req: RemoveLinkedWalletRequest) => ['API', 'removeLinkedWallet', req] as const,
    generateWaaSVerificationURL: (req: GenerateWaaSVerificationURLRequest) =>
      ['API', 'generateWaaSVerificationURL', req] as const,
    validateWaaSVerificationNonce: (req: ValidateWaaSVerificationNonceRequest) =>
      ['API', 'validateWaaSVerificationNonce', req] as const,
    listAdoptedWallets: (req: ListAdoptedWalletsRequest) => ['API', 'listAdoptedWallets', req] as const,
    getLifiChains: () => ['API', 'getLifiChains'] as const,
    getLifiTokens: (req: GetLifiTokensRequest) => ['API', 'getLifiTokens', req] as const,
    getLifiSwapRoutes: (req: GetLifiSwapRoutesRequest) => ['API', 'getLifiSwapRoutes', req] as const,
    getLifiSwapQuote: (req: GetLifiSwapQuoteRequest) => ['API', 'getLifiSwapQuote', req] as const,
    getIntentCallsPayloads: (req: GetIntentCallsPayloadsRequest) => ['API', 'getIntentCallsPayloads', req] as const,
    commitIntentConfig: (req: CommitIntentConfigRequest) => ['API', 'commitIntentConfig', req] as const,
    getIntentConfig: (req: GetIntentConfigRequest) => ['API', 'getIntentConfig', req] as const,
    listCurrencyGroups: () => ['API', 'listCurrencyGroups'] as const,
    addOffchainInventory: (req: AddOffchainInventoryRequest) => ['API', 'addOffchainInventory', req] as const,
    getOffchainInventory: (req: GetOffchainInventoryRequest) => ['API', 'getOffchainInventory', req] as const,
    listOffchainInventories: (req: ListOffchainInventoriesRequest) => ['API', 'listOffchainInventories', req] as const,
    updateOffchainInventory: (req: UpdateOffchainInventoryRequest) => ['API', 'updateOffchainInventory', req] as const,
    deleteOffchainInventory: (req: DeleteOffchainInventoryRequest) => ['API', 'deleteOffchainInventory', req] as const,
    requestOffchainPayment: (req: RequestOffchainPaymentRequest) => ['API', 'requestOffchainPayment', req] as const,
    listOffchainPayments: (req: ListOffchainPaymentsRequest) => ['API', 'listOffchainPayments', req] as const,
    savePack: (req: SavePackRequest) => ['API', 'savePack', req] as const,
    getPack: (req: GetPackRequest) => ['API', 'getPack', req] as const,
    getPackIds: (req: GetPackIdsRequest) => ['API', 'getPackIds', req] as const,
    deletePack: (req: DeletePackRequest) => ['API', 'deletePack', req] as const,
    updatePackContent: (req: UpdatePackContentRequest) => ['API', 'updatePackContent', req] as const,
    getRevealTxData: (req: GetRevealTxDataRequest) => ['API', 'getRevealTxData', req] as const,
    checkoutOptionsPrimary: (req: CheckoutOptionsPrimaryRequest) => ['API', 'checkoutOptionsPrimary', req] as const,
    checkoutOptionsSecondary: (req: CheckoutOptionsSecondaryRequest) =>
      ['API', 'checkoutOptionsSecondary', req] as const,
    checkoutOptionsGetTransakContractID: (req: CheckoutOptionsGetTransakContractIDRequest) =>
      ['API', 'checkoutOptionsGetTransakContractID', req] as const,
    fortePayCreateIntent: (req: FortePayCreateIntentRequest) => ['API', 'fortePayCreateIntent', req] as const,
    fortePayGetPaymentStatuses: (req: FortePayGetPaymentStatusesRequest) =>
      ['API', 'fortePayGetPaymentStatuses', req] as const,
    getCCTPTransfer: (req: GetCCTPTransferRequest) => ['API', 'getCCTPTransfer', req] as const,
    queueCCTPTransfer: (req: QueueCCTPTransferRequest) => ['API', 'queueCCTPTransfer', req] as const,
    queueIntentConfigExecution: (req: QueueIntentConfigExecutionRequest) =>
      ['API', 'queueIntentConfigExecution', req] as const,
    getIntentConfigExecutionStatus: (req: GetIntentConfigExecutionStatusRequest) =>
      ['API', 'getIntentConfigExecutionStatus', req] as const,
    listIntentConfigs: (req: ListIntentConfigsRequest) => ['API', 'listIntentConfigs', req] as const,
    queueMetaTxnReceipt: (req: QueueMetaTxnReceiptRequest) => ['API', 'queueMetaTxnReceipt', req] as const,
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingResponse> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<PingResponse>(_data, 'PingResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  version = (headers?: object, signal?: AbortSignal): Promise<VersionResponse> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<VersionResponse>(_data, 'VersionResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            version: <Version>_data.version,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RuntimeStatusResponse>(_data, 'RuntimeStatusResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <RuntimeStatus>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  clock = (headers?: object, signal?: AbortSignal): Promise<ClockResponse> => {
    return this.fetch(this.url('Clock'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ClockResponse>(_data, 'ClockResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  clock = (headers?: object, signal?: AbortSignal): Promise<ClockReturn> => {
    return this.fetch(this.url('Clock'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            serverTime: <string>_data.serverTime,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextResponse> => {
    return this.fetch(this.url('GetSequenceContext'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetSequenceContextResponse>(_data, 'GetSequenceContextResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn> => {
    return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <SequenceContext>_data.data,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getAuthToken = (req: GetAuthTokenRequest, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenResponse> => {
    return this.fetch(
      this.url('GetAuthToken'),
      createHttpRequest(JsonEncode(req, 'GetAuthTokenRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetAuthTokenResponse>(_data, 'GetAuthTokenResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getAuthToken = (args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn> => {
    return this.fetch(this.url('GetAuthToken'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
            jwtToken: <string>_data.jwtToken,
            address: <string>_data.address,
            user: <User>_data.user,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getAuthToken2 = (
    req: GetAuthToken2Request,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetAuthToken2Response> => {
    return this.fetch(
      this.url('GetAuthToken2'),
      createHttpRequest(JsonEncode(req, 'GetAuthToken2Request'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetAuthToken2Response>(_data, 'GetAuthToken2Response')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getAuthToken2 = (args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return> => {
    return this.fetch(this.url('GetAuthToken2'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
            jwtToken: <string>_data.jwtToken,
            address: <string>_data.address,
            user: <User>_data.user,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  sendPasswordlessLink = (
<<<<<<< Updated upstream
    req: SendPasswordlessLinkRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SendPasswordlessLinkResponse> => {
    return this.fetch(
      this.url('SendPasswordlessLink'),
      createHttpRequest(JsonEncode(req, 'SendPasswordlessLinkRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SendPasswordlessLinkResponse>(_data, 'SendPasswordlessLinkResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: SendPasswordlessLinkArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SendPasswordlessLinkReturn> => {
    return this.fetch(this.url('SendPasswordlessLink'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  registerPublicKey = (
<<<<<<< Updated upstream
    req: RegisterPublicKeyRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RegisterPublicKeyResponse> => {
    return this.fetch(
      this.url('RegisterPublicKey'),
      createHttpRequest(JsonEncode(req, 'RegisterPublicKeyRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RegisterPublicKeyResponse>(_data, 'RegisterPublicKeyResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: RegisterPublicKeyArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RegisterPublicKeyReturn> => {
    return this.fetch(this.url('RegisterPublicKey'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getPublicKey = (req: GetPublicKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyResponse> => {
    return this.fetch(
      this.url('GetPublicKey'),
      createHttpRequest(JsonEncode(req, 'GetPublicKeyRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetPublicKeyResponse>(_data, 'GetPublicKeyResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getPublicKey = (args: GetPublicKeyArgs, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyReturn> => {
    return this.fetch(this.url('GetPublicKey'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            publicKey: <PublicKey>_data.publicKey,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  friendList = (req: FriendListRequest, headers?: object, signal?: AbortSignal): Promise<FriendListResponse> => {
    return this.fetch(
      this.url('FriendList'),
      createHttpRequest(JsonEncode(req, 'FriendListRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<FriendListResponse>(_data, 'FriendListResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  friendList = (args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn> => {
    return this.fetch(this.url('FriendList'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            friends: <Array<Friend>>_data.friends,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getFriendByAddress = (
<<<<<<< Updated upstream
    req: GetFriendByAddressRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetFriendByAddressResponse> => {
    return this.fetch(
      this.url('GetFriendByAddress'),
      createHttpRequest(JsonEncode(req, 'GetFriendByAddressRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetFriendByAddressResponse>(_data, 'GetFriendByAddressResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetFriendByAddressArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetFriendByAddressReturn> => {
    return this.fetch(this.url('GetFriendByAddress'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
            friend: <Friend>_data.friend,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  searchFriends = (
    req: SearchFriendsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchFriendsResponse> => {
    return this.fetch(
      this.url('SearchFriends'),
      createHttpRequest(JsonEncode(req, 'SearchFriendsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchFriendsResponse>(_data, 'SearchFriendsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  searchFriends = (args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn> => {
    return this.fetch(this.url('SearchFriends'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            friends: <Array<Friend>>_data.friends,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  addFriend = (req: AddFriendRequest, headers?: object, signal?: AbortSignal): Promise<AddFriendResponse> => {
    return this.fetch(
      this.url('AddFriend'),
      createHttpRequest(JsonEncode(req, 'AddFriendRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<AddFriendResponse>(_data, 'AddFriendResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  addFriend = (args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn> => {
    return this.fetch(this.url('AddFriend'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
            friend: <Friend>_data.friend,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  updateFriendNickname = (
<<<<<<< Updated upstream
    req: UpdateFriendNicknameRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateFriendNicknameResponse> => {
    return this.fetch(
      this.url('UpdateFriendNickname'),
      createHttpRequest(JsonEncode(req, 'UpdateFriendNicknameRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateFriendNicknameResponse>(_data, 'UpdateFriendNicknameResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UpdateFriendNicknameArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateFriendNicknameReturn> => {
    return this.fetch(this.url('UpdateFriendNickname'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
            friend: <Friend>_data.friend,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  removeFriend = (req: RemoveFriendRequest, headers?: object, signal?: AbortSignal): Promise<RemoveFriendResponse> => {
    return this.fetch(
      this.url('RemoveFriend'),
      createHttpRequest(JsonEncode(req, 'RemoveFriendRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RemoveFriendResponse>(_data, 'RemoveFriendResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  removeFriend = (args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn> => {
    return this.fetch(this.url('RemoveFriend'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  contractCall = (req: ContractCallRequest, headers?: object, signal?: AbortSignal): Promise<ContractCallResponse> => {
    return this.fetch(
      this.url('ContractCall'),
      createHttpRequest(JsonEncode(req, 'ContractCallRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ContractCallResponse>(_data, 'ContractCallResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  contractCall = (args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn> => {
    return this.fetch(this.url('ContractCall'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            returns: <Array<string>>_data.returns,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  decodeContractCall = (
<<<<<<< Updated upstream
    req: DecodeContractCallRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DecodeContractCallResponse> => {
    return this.fetch(
      this.url('DecodeContractCall'),
      createHttpRequest(JsonEncode(req, 'DecodeContractCallRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DecodeContractCallResponse>(_data, 'DecodeContractCallResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: DecodeContractCallArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DecodeContractCallReturn> => {
    return this.fetch(this.url('DecodeContractCall'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            call: <ContractCall>_data.call,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  lookupContractCallSelectors = (
<<<<<<< Updated upstream
    req: LookupContractCallSelectorsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<LookupContractCallSelectorsResponse> => {
    return this.fetch(
      this.url('LookupContractCallSelectors'),
      createHttpRequest(JsonEncode(req, 'LookupContractCallSelectorsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<LookupContractCallSelectorsResponse>(_data, 'LookupContractCallSelectorsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: LookupContractCallSelectorsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<LookupContractCallSelectorsReturn> => {
    return this.fetch(this.url('LookupContractCallSelectors'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            signatures: <Array<Array<string>>>_data.signatures,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  userStorageFetch = (
<<<<<<< Updated upstream
    req: UserStorageFetchRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchResponse> => {
    return this.fetch(
      this.url('UserStorageFetch'),
      createHttpRequest(JsonEncode(req, 'UserStorageFetchRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UserStorageFetchResponse>(_data, 'UserStorageFetchResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UserStorageFetchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchReturn> => {
    return this.fetch(this.url('UserStorageFetch'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            object: <any>_data.object,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  userStorageSave = (
<<<<<<< Updated upstream
    req: UserStorageSaveRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageSaveResponse> => {
    return this.fetch(
      this.url('UserStorageSave'),
      createHttpRequest(JsonEncode(req, 'UserStorageSaveRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UserStorageSaveResponse>(_data, 'UserStorageSaveResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UserStorageSaveArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageSaveReturn> => {
    return this.fetch(this.url('UserStorageSave'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  userStorageDelete = (
<<<<<<< Updated upstream
    req: UserStorageDeleteRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageDeleteResponse> => {
    return this.fetch(
      this.url('UserStorageDelete'),
      createHttpRequest(JsonEncode(req, 'UserStorageDeleteRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UserStorageDeleteResponse>(_data, 'UserStorageDeleteResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UserStorageDeleteArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageDeleteReturn> => {
    return this.fetch(this.url('UserStorageDelete'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  userStorageFetchAll = (
<<<<<<< Updated upstream
    req: UserStorageFetchAllRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchAllResponse> => {
    return this.fetch(
      this.url('UserStorageFetchAll'),
      createHttpRequest(JsonEncode(req, 'UserStorageFetchAllRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UserStorageFetchAllResponse>(_data, 'UserStorageFetchAllResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UserStorageFetchAllArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UserStorageFetchAllReturn> => {
    return this.fetch(this.url('UserStorageFetchAll'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            objects: <{ [key: string]: any }>_data.objects,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getMoonpayLink = (
<<<<<<< Updated upstream
    req: GetMoonpayLinkRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetMoonpayLinkResponse> => {
    return this.fetch(
      this.url('GetMoonpayLink'),
      createHttpRequest(JsonEncode(req, 'GetMoonpayLinkRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetMoonpayLinkResponse>(_data, 'GetMoonpayLinkResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetMoonpayLinkArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetMoonpayLinkReturn> => {
    return this.fetch(this.url('GetMoonpayLink'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            signedUrl: <string>_data.signedUrl,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  resolveENSAddress = (
<<<<<<< Updated upstream
    req: ResolveENSAddressRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ResolveENSAddressResponse> => {
    return this.fetch(
      this.url('ResolveENSAddress'),
      createHttpRequest(JsonEncode(req, 'ResolveENSAddressRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ResolveENSAddressResponse>(_data, 'ResolveENSAddressResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ResolveENSAddressArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ResolveENSAddressReturn> => {
    return this.fetch(this.url('ResolveENSAddress'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            address: <string>_data.address,
            ok: <boolean>_data.ok,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  isValidSignature = (
<<<<<<< Updated upstream
    req: IsValidSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidSignatureResponse> => {
    return this.fetch(
      this.url('IsValidSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidSignatureRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsValidSignatureResponse>(_data, 'IsValidSignatureResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: IsValidSignatureArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidSignatureReturn> => {
    return this.fetch(this.url('IsValidSignature'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            isValid: <boolean>_data.isValid,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  isValidMessageSignature = (
<<<<<<< Updated upstream
    req: IsValidMessageSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidMessageSignatureResponse> => {
    return this.fetch(
      this.url('IsValidMessageSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidMessageSignatureRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsValidMessageSignatureResponse>(_data, 'IsValidMessageSignatureResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: IsValidMessageSignatureArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidMessageSignatureReturn> => {
    return this.fetch(this.url('IsValidMessageSignature'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            isValid: <boolean>_data.isValid,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  isValidTypedDataSignature = (
<<<<<<< Updated upstream
    req: IsValidTypedDataSignatureRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidTypedDataSignatureResponse> => {
    return this.fetch(
      this.url('IsValidTypedDataSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidTypedDataSignatureRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsValidTypedDataSignatureResponse>(_data, 'IsValidTypedDataSignatureResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: IsValidTypedDataSignatureArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidTypedDataSignatureReturn> => {
    return this.fetch(this.url('IsValidTypedDataSignature'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            isValid: <boolean>_data.isValid,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  isValidETHAuthProof = (
<<<<<<< Updated upstream
    req: IsValidETHAuthProofRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidETHAuthProofResponse> => {
    return this.fetch(
      this.url('IsValidETHAuthProof'),
      createHttpRequest(JsonEncode(req, 'IsValidETHAuthProofRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsValidETHAuthProofResponse>(_data, 'IsValidETHAuthProofResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: IsValidETHAuthProofArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidETHAuthProofReturn> => {
    return this.fetch(this.url('IsValidETHAuthProof'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            isValid: <boolean>_data.isValid,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getOnRampURL = (req: GetOnRampURLRequest, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLResponse> => {
    return this.fetch(
      this.url('GetOnRampURL'),
      createHttpRequest(JsonEncode(req, 'GetOnRampURLRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetOnRampURLResponse>(_data, 'GetOnRampURLResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getOnRampURL = (args: GetOnRampURLArgs, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLReturn> => {
    return this.fetch(this.url('GetOnRampURL'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            url: <string>_data.url,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  transakGetCountries = (headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesResponse> => {
    return this.fetch(this.url('TransakGetCountries'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetCountriesResponse>(_data, 'TransakGetCountriesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  sardineGetClientToken = (headers?: object, signal?: AbortSignal): Promise<SardineGetClientTokenReturn> => {
    return this.fetch(this.url('SardineGetClientToken'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            token: <string>_data.token,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  transakGetCryptoCurrencies = (
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetCryptoCurrenciesResponse> => {
    return this.fetch(this.url('TransakGetCryptoCurrencies'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetCryptoCurrenciesResponse>(_data, 'TransakGetCryptoCurrenciesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  sardineGetNFTCheckoutToken = (
    args: SardineGetNFTCheckoutTokenArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetNFTCheckoutTokenReturn> => {
    return this.fetch(this.url('SardineGetNFTCheckoutToken'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resp: <SardineNFTCheckout>_data.resp,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  transakGetFiatCurrencies = (headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesResponse> => {
    return this.fetch(this.url('TransakGetFiatCurrencies'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetFiatCurrenciesResponse>(_data, 'TransakGetFiatCurrenciesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
=======
  sardineGetNFTCheckoutOrderStatus = (
    args: SardineGetNFTCheckoutOrderStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetNFTCheckoutOrderStatusReturn> => {
    return this.fetch(this.url('SardineGetNFTCheckoutOrderStatus'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resp: <SardineOrder>_data.resp,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetSupportedRegions = (headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedRegionsReturn> => {
    return this.fetch(this.url('SardineGetSupportedRegions'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            regions: <Array<SardineRegion>>_data.regions,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetSupportedFiatCurrencies = (
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetSupportedFiatCurrenciesReturn> => {
    return this.fetch(this.url('SardineGetSupportedFiatCurrencies'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokens: <Array<SardineFiatCurrency>>_data.tokens,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetSupportedTokens = (headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedTokensReturn> => {
    return this.fetch(this.url('SardineGetSupportedTokens'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokens: <Array<SardineSupportedToken>>_data.tokens,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetSupportedTokenForSwap = (
    args: SardineGetSupportedTokenForSwapArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetSupportedTokenForSwapReturn> => {
    return this.fetch(this.url('SardineGetSupportedTokenForSwap'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            token: <SardineSupportedTokenForSwap>_data.token,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetEnabledTokens = (headers?: object, signal?: AbortSignal): Promise<SardineGetEnabledTokensReturn> => {
    return this.fetch(this.url('SardineGetEnabledTokens'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokens: <Array<SardineEnabledToken>>_data.tokens,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  sardineGetQuote = (
    args: SardineGetQuoteArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SardineGetQuoteReturn> => {
    return this.fetch(this.url('SardineGetQuote'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            quote: <SardineQuote>_data.quote,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  getSardineClientToken = (headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn> => {
    return this.fetch(this.url('GetSardineClientToken'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            token: <string>_data.token,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  getSardineNFTCheckoutToken = (
    args: GetSardineNFTCheckoutTokenArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetSardineNFTCheckoutTokenReturn> => {
    return this.fetch(this.url('GetSardineNFTCheckoutToken'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resp: <SardineNFTCheckout>_data.resp,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  getSardineNFTCheckoutOrderStatus = (
    args: GetSardineNFTCheckoutOrderStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetSardineNFTCheckoutOrderStatusReturn> => {
    return this.fetch(this.url('GetSardineNFTCheckoutOrderStatus'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resp: <SardineOrder>_data.resp,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  transakGetCountries = (headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesReturn> => {
    return this.fetch(this.url('TransakGetCountries'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            regions: <Array<TransakCountry>>_data.regions,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  transakGetCryptoCurrencies = (headers?: object, signal?: AbortSignal): Promise<TransakGetCryptoCurrenciesReturn> => {
    return this.fetch(this.url('TransakGetCryptoCurrencies'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            currencies: <Array<TransakCryptoCurrency>>_data.currencies,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
    )
  }

  transakGetFiatCurrencies = (headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesReturn> => {
    return this.fetch(this.url('TransakGetFiatCurrencies'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            currencies: <Array<TransakFiatCurrency>>_data.currencies,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      },
>>>>>>> Stashed changes
    )
  }

  transakGetPrice = (
<<<<<<< Updated upstream
    req: TransakGetPriceRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetPriceResponse> => {
    return this.fetch(
      this.url('TransakGetPrice'),
      createHttpRequest(JsonEncode(req, 'TransakGetPriceRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetPriceResponse>(_data, 'TransakGetPriceResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: TransakGetPriceArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetPriceReturn> => {
    return this.fetch(this.url('TransakGetPrice'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            price: <TransakPrice>_data.price,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  transakGetSupportedNFTCheckoutChains = (
    headers?: object,
    signal?: AbortSignal,
<<<<<<< Updated upstream
  ): Promise<TransakGetSupportedNFTCheckoutChainsResponse> => {
    return this.fetch(this.url('TransakGetSupportedNFTCheckoutChains'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetSupportedNFTCheckoutChainsResponse>(
            _data,
            'TransakGetSupportedNFTCheckoutChainsResponse',
          )
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  ): Promise<TransakGetSupportedNFTCheckoutChainsReturn> => {
    return this.fetch(this.url('TransakGetSupportedNFTCheckoutChains'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            chains: <Array<TransakChain>>_data.chains,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  transakGetWidgetURL = (
    req: TransakGetWidgetURLRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<TransakGetWidgetURLResponse> => {
    return this.fetch(
      this.url('TransakGetWidgetURL'),
      createHttpRequest(JsonEncode(req, 'TransakGetWidgetURLRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<TransakGetWidgetURLResponse>(_data, 'TransakGetWidgetURLResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getCoinPrices = (
    req: GetCoinPricesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCoinPricesResponse> => {
    return this.fetch(
      this.url('GetCoinPrices'),
      createHttpRequest(JsonEncode(req, 'GetCoinPricesRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetCoinPricesResponse>(_data, 'GetCoinPricesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getCoinPrices = (args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn> => {
    return this.fetch(this.url('GetCoinPrices'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokenPrices: <Array<TokenPrice>>_data.tokenPrices,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getCollectiblePrices = (
<<<<<<< Updated upstream
    req: GetCollectiblePricesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCollectiblePricesResponse> => {
    return this.fetch(
      this.url('GetCollectiblePrices'),
      createHttpRequest(JsonEncode(req, 'GetCollectiblePricesRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetCollectiblePricesResponse>(_data, 'GetCollectiblePricesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetCollectiblePricesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCollectiblePricesReturn> => {
    return this.fetch(this.url('GetCollectiblePrices'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokenPrices: <Array<TokenPrice>>_data.tokenPrices,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getExchangeRate = (
<<<<<<< Updated upstream
    req: GetExchangeRateRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetExchangeRateResponse> => {
    return this.fetch(
      this.url('GetExchangeRate'),
      createHttpRequest(JsonEncode(req, 'GetExchangeRateRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetExchangeRateResponse>(_data, 'GetExchangeRateResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetExchangeRateArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetExchangeRateReturn> => {
    return this.fetch(this.url('GetExchangeRate'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            exchangeRate: <ExchangeRate>_data.exchangeRate,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  memoryStore = (req: MemoryStoreRequest, headers?: object, signal?: AbortSignal): Promise<MemoryStoreResponse> => {
    return this.fetch(
      this.url('MemoryStore'),
      createHttpRequest(JsonEncode(req, 'MemoryStoreRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<MemoryStoreResponse>(_data, 'MemoryStoreResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  memoryStore = (args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn> => {
    return this.fetch(this.url('MemoryStore'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  memoryLoad = (req: MemoryLoadRequest, headers?: object, signal?: AbortSignal): Promise<MemoryLoadResponse> => {
    return this.fetch(
      this.url('MemoryLoad'),
      createHttpRequest(JsonEncode(req, 'MemoryLoadRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<MemoryLoadResponse>(_data, 'MemoryLoadResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  memoryLoad = (args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn> => {
    return this.fetch(this.url('MemoryLoad'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            value: <string>_data.value,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getInviteInfo = (headers?: object, signal?: AbortSignal): Promise<GetInviteInfoResponse> => {
    return this.fetch(this.url('GetInviteInfo'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetInviteInfoResponse>(_data, 'GetInviteInfoResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getInviteInfo = (headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn> => {
    return this.fetch(this.url('GetInviteInfo'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inviteInfo: <InviteInfo>_data.inviteInfo,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  isValidAccessCode = (
<<<<<<< Updated upstream
    req: IsValidAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidAccessCodeResponse> => {
    return this.fetch(
      this.url('IsValidAccessCode'),
      createHttpRequest(JsonEncode(req, 'IsValidAccessCodeRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsValidAccessCodeResponse>(_data, 'IsValidAccessCodeResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: IsValidAccessCodeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsValidAccessCodeReturn> => {
    return this.fetch(this.url('IsValidAccessCode'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  internalClaimAccessCode = (
<<<<<<< Updated upstream
    req: InternalClaimAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<InternalClaimAccessCodeResponse> => {
    return this.fetch(
      this.url('InternalClaimAccessCode'),
      createHttpRequest(JsonEncode(req, 'InternalClaimAccessCodeRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<InternalClaimAccessCodeResponse>(_data, 'InternalClaimAccessCodeResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: InternalClaimAccessCodeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<InternalClaimAccessCodeReturn> => {
    return this.fetch(this.url('InternalClaimAccessCode'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  blockNumberAtTime = (
<<<<<<< Updated upstream
    req: BlockNumberAtTimeRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<BlockNumberAtTimeResponse> => {
    return this.fetch(
      this.url('BlockNumberAtTime'),
      createHttpRequest(JsonEncode(req, 'BlockNumberAtTimeRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<BlockNumberAtTimeResponse>(_data, 'BlockNumberAtTimeResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: BlockNumberAtTimeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<BlockNumberAtTimeReturn> => {
    return this.fetch(this.url('BlockNumberAtTime'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            blocks: <Array<number>>_data.blocks,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  paperSessionSecret = (
<<<<<<< Updated upstream
    req: PaperSessionSecretRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecretResponse> => {
    return this.fetch(
      this.url('PaperSessionSecret'),
      createHttpRequest(JsonEncode(req, 'PaperSessionSecretRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<PaperSessionSecretResponse>(_data, 'PaperSessionSecretResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: PaperSessionSecretArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecretReturn> => {
    return this.fetch(this.url('PaperSessionSecret'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            secret: <string>_data.secret,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  paperSessionSecret2 = (
<<<<<<< Updated upstream
    req: PaperSessionSecret2Request,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecret2Response> => {
    return this.fetch(
      this.url('PaperSessionSecret2'),
      createHttpRequest(JsonEncode(req, 'PaperSessionSecret2Request'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<PaperSessionSecret2Response>(_data, 'PaperSessionSecret2Response')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: PaperSessionSecret2Args,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PaperSessionSecret2Return> => {
    return this.fetch(this.url('PaperSessionSecret2'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            secret: <string>_data.secret,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  linkWallet = (req: LinkWalletRequest, headers?: object, signal?: AbortSignal): Promise<LinkWalletResponse> => {
    return this.fetch(
      this.url('LinkWallet'),
      createHttpRequest(JsonEncode(req, 'LinkWalletRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<LinkWalletResponse>(_data, 'LinkWalletResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  linkWallet = (args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn> => {
    return this.fetch(this.url('LinkWallet'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getLinkedWallets = (
<<<<<<< Updated upstream
    req: GetLinkedWalletsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLinkedWalletsResponse> => {
    return this.fetch(
      this.url('GetLinkedWallets'),
      createHttpRequest(JsonEncode(req, 'GetLinkedWalletsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetLinkedWalletsResponse>(_data, 'GetLinkedWalletsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetLinkedWalletsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLinkedWalletsReturn> => {
    return this.fetch(this.url('GetLinkedWallets'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            linkedWallets: <Array<LinkedWallet>>_data.linkedWallets,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  removeLinkedWallet = (
<<<<<<< Updated upstream
    req: RemoveLinkedWalletRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveLinkedWalletResponse> => {
    return this.fetch(
      this.url('RemoveLinkedWallet'),
      createHttpRequest(JsonEncode(req, 'RemoveLinkedWalletRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RemoveLinkedWalletResponse>(_data, 'RemoveLinkedWalletResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: RemoveLinkedWalletArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveLinkedWalletReturn> => {
    return this.fetch(this.url('RemoveLinkedWallet'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  generateWaaSVerificationURL = (
<<<<<<< Updated upstream
    req: GenerateWaaSVerificationURLRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GenerateWaaSVerificationURLResponse> => {
    return this.fetch(
      this.url('GenerateWaaSVerificationURL'),
      createHttpRequest(JsonEncode(req, 'GenerateWaaSVerificationURLRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GenerateWaaSVerificationURLResponse>(_data, 'GenerateWaaSVerificationURLResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GenerateWaaSVerificationURLArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GenerateWaaSVerificationURLReturn> => {
    return this.fetch(this.url('GenerateWaaSVerificationURL'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            nonce: <string>_data.nonce,
            verificationURL: <string>_data.verificationURL,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  validateWaaSVerificationNonce = (
<<<<<<< Updated upstream
    req: ValidateWaaSVerificationNonceRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ValidateWaaSVerificationNonceResponse> => {
    return this.fetch(
      this.url('ValidateWaaSVerificationNonce'),
      createHttpRequest(JsonEncode(req, 'ValidateWaaSVerificationNonceRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ValidateWaaSVerificationNonceResponse>(_data, 'ValidateWaaSVerificationNonceResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ValidateWaaSVerificationNonceArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ValidateWaaSVerificationNonceReturn> => {
    return this.fetch(this.url('ValidateWaaSVerificationNonce'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletAddress: <string>_data.walletAddress,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  listAdoptedWallets = (
<<<<<<< Updated upstream
    req: ListAdoptedWalletsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListAdoptedWalletsResponse> => {
    return this.fetch(
      this.url('ListAdoptedWallets'),
      createHttpRequest(JsonEncode(req, 'ListAdoptedWalletsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListAdoptedWalletsResponse>(_data, 'ListAdoptedWalletsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ListAdoptedWalletsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListAdoptedWalletsReturn> => {
    return this.fetch(this.url('ListAdoptedWallets'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            wallets: <Array<AdoptedChildWallet>>_data.wallets,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getLifiChains = (headers?: object, signal?: AbortSignal): Promise<GetLifiChainsResponse> => {
    return this.fetch(this.url('GetLifiChains'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetLifiChainsResponse>(_data, 'GetLifiChainsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getLifiChains = (headers?: object, signal?: AbortSignal): Promise<GetLifiChainsReturn> => {
    return this.fetch(this.url('GetLifiChains'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            chains: <Array<number>>_data.chains,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getLifiTokens = (
    req: GetLifiTokensRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiTokensResponse> => {
    return this.fetch(
      this.url('GetLifiTokens'),
      createHttpRequest(JsonEncode(req, 'GetLifiTokensRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetLifiTokensResponse>(_data, 'GetLifiTokensResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getLifiTokens = (args: GetLifiTokensArgs, headers?: object, signal?: AbortSignal): Promise<GetLifiTokensReturn> => {
    return this.fetch(this.url('GetLifiTokens'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tokens: <Array<Token>>_data.tokens,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getLifiSwapRoutes = (
<<<<<<< Updated upstream
    req: GetLifiSwapRoutesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapRoutesResponse> => {
    return this.fetch(
      this.url('GetLifiSwapRoutes'),
      createHttpRequest(JsonEncode(req, 'GetLifiSwapRoutesRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetLifiSwapRoutesResponse>(_data, 'GetLifiSwapRoutesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetLifiSwapRoutesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapRoutesReturn> => {
    return this.fetch(this.url('GetLifiSwapRoutes'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            routes: <Array<LifiSwapRoute>>_data.routes,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getLifiSwapQuote = (
<<<<<<< Updated upstream
    req: GetLifiSwapQuoteRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapQuoteResponse> => {
    return this.fetch(
      this.url('GetLifiSwapQuote'),
      createHttpRequest(JsonEncode(req, 'GetLifiSwapQuoteRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetLifiSwapQuoteResponse>(_data, 'GetLifiSwapQuoteResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetLifiSwapQuoteArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetLifiSwapQuoteReturn> => {
    return this.fetch(this.url('GetLifiSwapQuote'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            quote: <LifiSwapQuote>_data.quote,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getIntentCallsPayloads = (
<<<<<<< Updated upstream
    req: GetIntentCallsPayloadsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentCallsPayloadsResponse> => {
    return this.fetch(
      this.url('GetIntentCallsPayloads'),
      createHttpRequest(JsonEncode(req, 'GetIntentCallsPayloadsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetIntentCallsPayloadsResponse>(_data, 'GetIntentCallsPayloadsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetIntentCallsPayloadsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentCallsPayloadsReturn> => {
    return this.fetch(this.url('GetIntentCallsPayloads'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            calls: <Array<IntentCallsPayload>>_data.calls,
            preconditions: <Array<IntentPrecondition>>_data.preconditions,
            metaTxns: <Array<MetaTxn>>_data.metaTxns,
            trailsFee: <TrailsFee>_data.trailsFee,
            quote: <IntentQuote>_data.quote,
            feeQuotes: <{ [key: string]: string }>_data.feeQuotes,
            originIntentAddress: <string>_data.originIntentAddress,
            destinationIntentAddress: <string>_data.destinationIntentAddress,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  commitIntentConfig = (
<<<<<<< Updated upstream
    req: CommitIntentConfigRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CommitIntentConfigResponse> => {
    return this.fetch(
      this.url('CommitIntentConfig'),
      createHttpRequest(JsonEncode(req, 'CommitIntentConfigRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CommitIntentConfigResponse>(_data, 'CommitIntentConfigResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: CommitIntentConfigArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CommitIntentConfigReturn> => {
    return this.fetch(this.url('CommitIntentConfig'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <IntentConfig>_data.config,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getIntentConfig = (
<<<<<<< Updated upstream
    req: GetIntentConfigRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigResponse> => {
    return this.fetch(
      this.url('GetIntentConfig'),
      createHttpRequest(JsonEncode(req, 'GetIntentConfigRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetIntentConfigResponse>(_data, 'GetIntentConfigResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetIntentConfigArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigReturn> => {
    return this.fetch(this.url('GetIntentConfig'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <IntentConfig>_data.config,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  listCurrencyGroups = (headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsResponse> => {
    return this.fetch(this.url('ListCurrencyGroups'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListCurrencyGroupsResponse>(_data, 'ListCurrencyGroupsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  listCurrencyGroups = (headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn> => {
    return this.fetch(this.url('ListCurrencyGroups'), createHTTPRequest({}, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            currencyGroups: <Array<CurrencyGroup>>_data.currencyGroups,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  addOffchainInventory = (
<<<<<<< Updated upstream
    req: AddOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddOffchainInventoryResponse> => {
    return this.fetch(
      this.url('AddOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'AddOffchainInventoryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<AddOffchainInventoryResponse>(_data, 'AddOffchainInventoryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: AddOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddOffchainInventoryReturn> => {
    return this.fetch(this.url('AddOffchainInventory'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventoryId: <number>_data.inventoryId,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getOffchainInventory = (
<<<<<<< Updated upstream
    req: GetOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetOffchainInventoryResponse> => {
    return this.fetch(
      this.url('GetOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'GetOffchainInventoryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetOffchainInventoryResponse>(_data, 'GetOffchainInventoryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetOffchainInventoryReturn> => {
    return this.fetch(this.url('GetOffchainInventory'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventory: <OffchainInventory>_data.inventory,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  listOffchainInventories = (
<<<<<<< Updated upstream
    req: ListOffchainInventoriesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainInventoriesResponse> => {
    return this.fetch(
      this.url('ListOffchainInventories'),
      createHttpRequest(JsonEncode(req, 'ListOffchainInventoriesRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListOffchainInventoriesResponse>(_data, 'ListOffchainInventoriesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ListOffchainInventoriesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainInventoriesReturn> => {
    return this.fetch(this.url('ListOffchainInventories'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventory: <Array<OffchainInventory>>_data.inventory,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  updateOffchainInventory = (
<<<<<<< Updated upstream
    req: UpdateOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateOffchainInventoryResponse> => {
    return this.fetch(
      this.url('UpdateOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'UpdateOffchainInventoryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateOffchainInventoryResponse>(_data, 'UpdateOffchainInventoryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UpdateOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateOffchainInventoryReturn> => {
    return this.fetch(this.url('UpdateOffchainInventory'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {}
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  deleteOffchainInventory = (
<<<<<<< Updated upstream
    req: DeleteOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteOffchainInventoryResponse> => {
    return this.fetch(
      this.url('DeleteOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'DeleteOffchainInventoryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeleteOffchainInventoryResponse>(_data, 'DeleteOffchainInventoryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: DeleteOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteOffchainInventoryReturn> => {
    return this.fetch(this.url('DeleteOffchainInventory'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  requestOffchainPayment = (
<<<<<<< Updated upstream
    req: RequestOffchainPaymentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RequestOffchainPaymentResponse> => {
    return this.fetch(
      this.url('RequestOffchainPayment'),
      createHttpRequest(JsonEncode(req, 'RequestOffchainPaymentRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RequestOffchainPaymentResponse>(_data, 'RequestOffchainPaymentResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: RequestOffchainPaymentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RequestOffchainPaymentReturn> => {
    return this.fetch(this.url('RequestOffchainPayment'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            payment: <PaymentResponse>_data.payment,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  listOffchainPayments = (
<<<<<<< Updated upstream
    req: ListOffchainPaymentsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainPaymentsResponse> => {
    return this.fetch(
      this.url('ListOffchainPayments'),
      createHttpRequest(JsonEncode(req, 'ListOffchainPaymentsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListOffchainPaymentsResponse>(_data, 'ListOffchainPaymentsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ListOffchainPaymentsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListOffchainPaymentsReturn> => {
    return this.fetch(this.url('ListOffchainPayments'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            payments: <Array<OffchainPayment>>_data.payments,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  savePack = (req: SavePackRequest, headers?: object, signal?: AbortSignal): Promise<SavePackResponse> => {
    return this.fetch(
      this.url('SavePack'),
      createHttpRequest(JsonEncode(req, 'SavePackRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SavePackResponse>(_data, 'SavePackResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  savePack = (args: SavePackArgs, headers?: object, signal?: AbortSignal): Promise<SavePackReturn> => {
    return this.fetch(this.url('SavePack'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            merkleRoot: <string>_data.merkleRoot,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getPack = (req: GetPackRequest, headers?: object, signal?: AbortSignal): Promise<GetPackResponse> => {
    return this.fetch(this.url('GetPack'), createHttpRequest(JsonEncode(req, 'GetPackRequest'), headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetPackResponse>(_data, 'GetPackResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getPack = (args: GetPackArgs, headers?: object, signal?: AbortSignal): Promise<GetPackReturn> => {
    return this.fetch(this.url('GetPack'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            pack: <Pack>_data.pack,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  getPackIds = (req: GetPackIdsRequest, headers?: object, signal?: AbortSignal): Promise<GetPackIdsResponse> => {
    return this.fetch(
      this.url('GetPackIds'),
      createHttpRequest(JsonEncode(req, 'GetPackIdsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetPackIdsResponse>(_data, 'GetPackIdsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  getPackIds = (args: GetPackIdsArgs, headers?: object, signal?: AbortSignal): Promise<GetPackIdsReturn> => {
    return this.fetch(this.url('GetPackIds'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            packIds: <Array<string>>_data.packIds,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

<<<<<<< Updated upstream
  deletePack = (req: DeletePackRequest, headers?: object, signal?: AbortSignal): Promise<DeletePackResponse> => {
    return this.fetch(
      this.url('DeletePack'),
      createHttpRequest(JsonEncode(req, 'DeletePackRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeletePackResponse>(_data, 'DeletePackResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
  deletePack = (args: DeletePackArgs, headers?: object, signal?: AbortSignal): Promise<DeletePackReturn> => {
    return this.fetch(this.url('DeletePack'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  updatePackContent = (
<<<<<<< Updated upstream
    req: UpdatePackContentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdatePackContentResponse> => {
    return this.fetch(
      this.url('UpdatePackContent'),
      createHttpRequest(JsonEncode(req, 'UpdatePackContentRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdatePackContentResponse>(_data, 'UpdatePackContentResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: UpdatePackContentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdatePackContentReturn> => {
    return this.fetch(this.url('UpdatePackContent'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            merkleRoot: <string>_data.merkleRoot,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getRevealTxData = (
<<<<<<< Updated upstream
    req: GetRevealTxDataRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetRevealTxDataResponse> => {
    return this.fetch(
      this.url('GetRevealTxData'),
      createHttpRequest(JsonEncode(req, 'GetRevealTxDataRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetRevealTxDataResponse>(_data, 'GetRevealTxDataResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetRevealTxDataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetRevealTxDataReturn> => {
    return this.fetch(this.url('GetRevealTxData'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            txData: <string>_data.txData,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  checkoutOptionsPrimary = (
<<<<<<< Updated upstream
    req: CheckoutOptionsPrimaryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsPrimaryResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsPrimary'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsPrimaryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CheckoutOptionsPrimaryResponse>(_data, 'CheckoutOptionsPrimaryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: CheckoutOptionsPrimaryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsPrimaryReturn> => {
    return this.fetch(this.url('CheckoutOptionsPrimary'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            options: <CheckoutOptions>_data.options,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  checkoutOptionsSecondary = (
<<<<<<< Updated upstream
    req: CheckoutOptionsSecondaryRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsSecondaryResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsSecondary'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsSecondaryRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CheckoutOptionsSecondaryResponse>(_data, 'CheckoutOptionsSecondaryResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: CheckoutOptionsSecondaryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsSecondaryReturn> => {
    return this.fetch(this.url('CheckoutOptionsSecondary'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            options: <CheckoutOptions>_data.options,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  checkoutOptionsGetTransakContractID = (
<<<<<<< Updated upstream
    req: CheckoutOptionsGetTransakContractIDRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsGetTransakContractIDResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsGetTransakContractID'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsGetTransakContractIDRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CheckoutOptionsGetTransakContractIDResponse>(
            _data,
            'CheckoutOptionsGetTransakContractIDResponse',
          )
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: CheckoutOptionsGetTransakContractIDArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CheckoutOptionsGetTransakContractIDReturn> => {
    return this.fetch(this.url('CheckoutOptionsGetTransakContractID'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contractId: <string>_data.contractId,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  fortePayCreateIntent = (
<<<<<<< Updated upstream
    req: FortePayCreateIntentRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayCreateIntentResponse> => {
    return this.fetch(
      this.url('FortePayCreateIntent'),
      createHttpRequest(JsonEncode(req, 'FortePayCreateIntentRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<FortePayCreateIntentResponse>(_data, 'FortePayCreateIntentResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: FortePayCreateIntentArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayCreateIntentReturn> => {
    return this.fetch(this.url('FortePayCreateIntent'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resp: <FortePayIntent>_data.resp,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  fortePayGetPaymentStatuses = (
<<<<<<< Updated upstream
    req: FortePayGetPaymentStatusesRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayGetPaymentStatusesResponse> => {
    return this.fetch(
      this.url('FortePayGetPaymentStatuses'),
      createHttpRequest(JsonEncode(req, 'FortePayGetPaymentStatusesRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<FortePayGetPaymentStatusesResponse>(_data, 'FortePayGetPaymentStatusesResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: FortePayGetPaymentStatusesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FortePayGetPaymentStatusesReturn> => {
    return this.fetch(this.url('FortePayGetPaymentStatuses'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            statuses: <Array<FortePaymentStatus>>_data.statuses,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getCCTPTransfer = (
<<<<<<< Updated upstream
    req: GetCCTPTransferRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCCTPTransferResponse> => {
    return this.fetch(
      this.url('GetCCTPTransfer'),
      createHttpRequest(JsonEncode(req, 'GetCCTPTransferRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetCCTPTransferResponse>(_data, 'GetCCTPTransferResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetCCTPTransferArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetCCTPTransferReturn> => {
    return this.fetch(this.url('GetCCTPTransfer'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            transfer: <CCTPTransfer>_data.transfer,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  queueCCTPTransfer = (
<<<<<<< Updated upstream
    req: QueueCCTPTransferRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueCCTPTransferResponse> => {
    return this.fetch(
      this.url('QueueCCTPTransfer'),
      createHttpRequest(JsonEncode(req, 'QueueCCTPTransferRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<QueueCCTPTransferResponse>(_data, 'QueueCCTPTransferResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: QueueCCTPTransferArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueCCTPTransferReturn> => {
    return this.fetch(this.url('QueueCCTPTransfer'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            transfer: <CCTPTransfer>_data.transfer,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  queueIntentConfigExecution = (
<<<<<<< Updated upstream
    req: QueueIntentConfigExecutionRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueIntentConfigExecutionResponse> => {
    return this.fetch(
      this.url('QueueIntentConfigExecution'),
      createHttpRequest(JsonEncode(req, 'QueueIntentConfigExecutionRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<QueueIntentConfigExecutionResponse>(_data, 'QueueIntentConfigExecutionResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: QueueIntentConfigExecutionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueIntentConfigExecutionReturn> => {
    return this.fetch(this.url('QueueIntentConfigExecution'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  getIntentConfigExecutionStatus = (
<<<<<<< Updated upstream
    req: GetIntentConfigExecutionStatusRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigExecutionStatusResponse> => {
    return this.fetch(
      this.url('GetIntentConfigExecutionStatus'),
      createHttpRequest(JsonEncode(req, 'GetIntentConfigExecutionStatusRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetIntentConfigExecutionStatusResponse>(_data, 'GetIntentConfigExecutionStatusResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: GetIntentConfigExecutionStatusArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetIntentConfigExecutionStatusReturn> => {
    return this.fetch(this.url('GetIntentConfigExecutionStatus'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            executionStatus: <string>_data.executionStatus,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  listIntentConfigs = (
<<<<<<< Updated upstream
    req: ListIntentConfigsRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListIntentConfigsResponse> => {
    return this.fetch(
      this.url('ListIntentConfigs'),
      createHttpRequest(JsonEncode(req, 'ListIntentConfigsRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListIntentConfigsResponse>(_data, 'ListIntentConfigsResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: ListIntentConfigsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListIntentConfigsReturn> => {
    return this.fetch(this.url('ListIntentConfigs'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            intentConfigs: <Array<IntentConfig>>_data.intentConfigs,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }

  queueMetaTxnReceipt = (
<<<<<<< Updated upstream
    req: QueueMetaTxnReceiptRequest,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueMetaTxnReceiptResponse> => {
    return this.fetch(
      this.url('QueueMetaTxnReceipt'),
      createHttpRequest(JsonEncode(req, 'QueueMetaTxnReceiptRequest'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<QueueMetaTxnReceiptResponse>(_data, 'QueueMetaTxnReceiptResponse')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
=======
    args: QueueMetaTxnReceiptArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<QueueMetaTxnReceiptReturn> => {
    return this.fetch(this.url('QueueMetaTxnReceipt'), createHTTPRequest(args, headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          }
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
>>>>>>> Stashed changes
      },
    )
  }
}

<<<<<<< Updated upstream
const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = {
    ...headers,
    'Content-Type': 'application/json',
    [WebrpcHeader]: WebrpcHeaderValue,
  }
  return { method: 'POST', headers: reqHeaders, body, signal }
=======
const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  reqHeaders[WebrpcHeader] = WebrpcHeaderValue

  return {
    method: 'POST',
    headers: reqHeaders,
    body: JSON.stringify(body || {}),
    signal,
  }
>>>>>>> Stashed changes
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then((text) => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
<<<<<<< Updated upstream
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`,
=======
      let message = ''
      if (error instanceof Error) {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`,
>>>>>>> Stashed changes
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

<<<<<<< Updated upstream
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}

=======
>>>>>>> Stashed changes
//
// Errors
//

<<<<<<< Updated upstream
type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
<<<<<<< Updated upstream
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = `endpoint error`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = `request failed`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = `bad route`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = `bad method`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = `bad request`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = `bad response`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = `server panic`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = `internal error`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

<<<<<<< Updated upstream
export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
=======
export class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcClientDisconnected',
    code: number = -8,
    message: string = `client disconnected`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)
>>>>>>> Stashed changes
  }
}

export class WebrpcStreamLostError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcStreamLost',
    code: number = -9,
    message: string = `stream lost`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'WebrpcStreamFinished',
    code: number = -10,
    message: string = `stream finished`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

<<<<<<< Updated upstream
//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
=======
// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 1000,
    message: string = `Unauthorized access`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'PermissionDenied',
    code: number = 1001,
    message: string = `Permission denied`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'SessionExpired',
    code: number = 1002,
    message: string = `Session expired`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'MethodNotFound',
    code: number = 1003,
    message: string = `Method not found`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'RequestConflict',
    code: number = 1004,
    message: string = `Conflict with target resource`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'Aborted',
    code: number = 1005,
    message: string = `Request aborted`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'Geoblocked',
    code: number = 1006,
    message: string = `Geoblocked region`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'RateLimited',
    code: number = 1007,
    message: string = `Rate-limited. Please slow down.`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'ProjectNotFound',
    code: number = 1008,
    message: string = `Project not found`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'AccessKeyNotFound',
    code: number = 1101,
    message: string = `Access key not found`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'AccessKeyMismatch',
    code: number = 1102,
    message: string = `Access key mismatch`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'InvalidOrigin',
    code: number = 1103,
    message: string = `Invalid origin for Access Key`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'InvalidService',
    code: number = 1104,
    message: string = `Service not enabled for Access key`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'UnauthorizedUser',
    code: number = 1105,
    message: string = `Unauthorized user`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota request exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'QuotaExceeded',
    code: number = 1200,
    message: string = `Quota request exceeded`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Quota rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'QuotaRateLimit',
    code: number = 1201,
    message: string = `Quota rate limit exceeded`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'NoDefaultKey',
    code: number = 1300,
    message: string = `No default access key found`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'MaxAccessKeys',
    code: number = 1301,
    message: string = `Access keys limit reached`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'AtLeastOneKey',
    code: number = 1302,
    message: string = `You need at least one Access Key`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'Timeout',
    code: number = 1900,
    message: string = `Request timed out`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2000
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'InvalidArgument',
    code: number = 2000,
    message: string = `Invalid argument`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unavailable'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Unavailable resource`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'Unavailable',
    code: number = 2002,
    message: string = `Unavailable resource`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'QueryFailed',
    code: number = 2003,
    message: string = `Query failed`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 3000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'NotFound',
    code: number = 3000,
    message: string = `Resource not found`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UnsupportedNetworkError extends WebrpcError {
<<<<<<< Updated upstream
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnsupportedNetwork'
    this.code = typeof error.code === 'number' ? error.code : 3008
    this.message = error.message || `Unsupported network`
    this.status = typeof error.status === 'number' ? error.status : 422
    if (error.cause !== undefined) this.cause = error.cause
=======
  constructor(
    name: string = 'UnsupportedNetwork',
    code: number = 3008,
    message: string = `Unsupported network`,
    status: number = 0,
    cause?: string,
  ) {
    super(name, code, message, status, cause)
>>>>>>> Stashed changes
    Object.setPrototypeOf(this, UnsupportedNetworkError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
<<<<<<< Updated upstream
  WebrpcClientAborted = 'WebrpcClientAborted',
=======
  WebrpcClientDisconnected = 'WebrpcClientDisconnected',
>>>>>>> Stashed changes
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  Unavailable = 'Unavailable',
  QueryFailed = 'QueryFailed',
  NotFound = 'NotFound',
  UnsupportedNetwork = 'UnsupportedNetwork',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
<<<<<<< Updated upstream
  WebrpcClientAborted = -8,
=======
  WebrpcClientDisconnected = -8,
>>>>>>> Stashed changes
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  InvalidArgument = 2000,
  Unavailable = 2002,
  QueryFailed = 2003,
  NotFound = 3000,
  UnsupportedNetwork = 3008,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
<<<<<<< Updated upstream
  [-8]: WebrpcClientAbortedError,
=======
  [-8]: WebrpcClientDisconnectedError,
>>>>>>> Stashed changes
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2000]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [3000]: NotFoundError,
  [3008]: UnsupportedNetworkError,
}

<<<<<<< Updated upstream
//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.31.0;gen-typescript@v0.22.5;sequence-api@v0.4.0'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? '',
  }
}
=======
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
>>>>>>> Stashed changes
